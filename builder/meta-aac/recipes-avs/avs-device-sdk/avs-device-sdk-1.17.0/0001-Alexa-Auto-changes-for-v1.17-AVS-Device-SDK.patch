From ad40220820b4f28419d0acd8d12bb3fb2db8b7fa Mon Sep 17 00:00:00 2001
From: Muni Sakkuru <muni.sakkuru@gmail.com>
Date: Wed, 23 Jun 2021 11:47:55 -0700
Subject: [PATCH] Alexa Auto changes for v1.17 AVS Device SDK

For internal reference: 0f74be58+8d039eff (1.17+aac)
---
 ACL/src/AVSConnectionManager.cpp              |   4 +-
 ADSL/include/ADSL/DirectiveProcessor.h        |  15 +-
 ADSL/include/ADSL/DirectiveSequencer.h        |   4 +
 ADSL/src/DirectiveProcessor.cpp               |  25 +-
 ADSL/src/DirectiveSequencer.cpp               |   8 +
 ADSL/test/ADSL/MockDirectiveSequencer.h       |   4 +
 AFML/include/AFML/FocusManager.h              |   2 +
 AFML/src/FocusManager.cpp                     |  27 +
 .../AVSCommon/AVS/DialogUXStateAggregator.h   |  12 +
 .../AVS/ExternalMediaPlayer/AdapterUtils.h    |  25 +-
 .../ExternalMediaAdapterConstants.h           |   9 +
 AVSCommon/AVS/src/DialogUXStateAggregator.cpp |  17 +-
 .../src/ExternalMediaPlayer/AdapterUtils.cpp  |  15 +-
 .../AVS/test/DialogUXStateAggregatorTest.cpp  |  17 +
 AVSCommon/CMakeLists.txt                      |   2 +
 .../CallStateObserverInterface.h              |  17 +-
 .../DirectiveSequencerInterface.h             |   4 +
 .../ExternalMediaAdapterHandlerInterface.h    | 126 ++++
 .../ExternalMediaAdapterInterface.h           |  36 ++
 .../ExternalMediaPlayerInterface.h            |  24 +-
 .../SDKInterfaces/FocusManagerInterface.h     |  11 +
 .../SDKInterfaces/MockDirectiveSequencer.h    |   4 +
 .../SDKInterfaces/MockFocusManager.h          |   1 +
 .../LibcurlUtils/CurlEasyHandleWrapper.h      |  24 +-
 .../AVSCommon/Utils/LibcurlUtils/HttpDelete.h |  83 +++
 .../Utils/LibcurlUtils/HttpDeleteInterface.h  |  53 ++
 .../AVSCommon/Utils/LibcurlUtils/HttpGet.h    |  83 +++
 .../Utils/LibcurlUtils/HttpGetInterface.h     |  53 ++
 .../LibcurlUtils/CurlEasyHandleWrapper.cpp    |  23 +-
 .../Utils/src/LibcurlUtils/HttpDelete.cpp     | 124 ++++
 AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp  | 124 ++++
 .../DefaultClient/src/DefaultClient.cpp       |   2 +
 CMakeLists.txt                                |   4 +
 .../include/Alerts/AlertObserverInterface.h   |  23 +
 .../include/Alerts/AlertsCapabilityAgent.h    |  41 ++
 .../Alerts/src/AlertsCapabilityAgent.cpp      |  54 ++
 .../include/AudioPlayer/AudioPlayer.h         |   7 +
 .../AudioPlayer/src/AudioPlayer.cpp           |  22 +-
 .../AudioPlayer/src/CMakeLists.txt            |   7 +-
 .../AudioPlayer/test/AudioPlayerTest.cpp      |  77 ++-
 .../DoNotDisturbCapabilityAgent.h             |  46 +-
 .../ExternalMediaPlayer/ExternalMediaPlayer.h | 100 ++++
 .../src/ExternalMediaPlayer.cpp               | 559 +++++++++++++++++-
 .../test/ExternalMediaPlayerTest.cpp          | 218 ++++++-
 .../MRM/include/MRM/MRMCapabilityAgent.h      |   6 +-
 .../MRM/src/MRMCapabilityAgent.cpp            |   6 +-
 .../PlaybackController/PlaybackController.h   |  14 +-
 .../src/PlaybackController.cpp                |  33 +-
 .../src/SpeechSynthesizer.cpp                 |  27 +-
 .../test/SpeechSynthesizerTest.cpp            | 137 +++++
 .../TemplateRuntime/src/TemplateRuntime.cpp   |   6 +-
 .../Implementation/src/SystemClockDelay.cpp   |   2 +-
 CertifiedSender/src/CertifiedSender.cpp       |   5 +-
 Endpoints/src/EndpointBuilder.cpp             |   4 +-
 .../test/AudioPlayerIntegrationTest.cpp       |  19 +
 .../include/SampleApp/InteractionManager.h    |   2 +-
 SampleApp/src/InteractionManager.cpp          |   2 +-
 57 files changed, 2285 insertions(+), 114 deletions(-)
 create mode 100644 AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalMediaAdapterHandlerInterface.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h
 create mode 100644 AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp
 create mode 100644 AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp

diff --git a/ACL/src/AVSConnectionManager.cpp b/ACL/src/AVSConnectionManager.cpp
index c9d16f3d..b2fe7111 100644
--- a/ACL/src/AVSConnectionManager.cpp
+++ b/ACL/src/AVSConnectionManager.cpp
@@ -138,7 +138,9 @@ void AVSConnectionManager::reconnect() {
 }
 
 void AVSConnectionManager::sendMessage(std::shared_ptr<avsCommon::avs::MessageRequest> request) {
-    m_messageRouter->sendMessage(request);
+    if (m_messageRouter != nullptr) {
+        m_messageRouter->sendMessage(request);
+    }
 }
 
 bool AVSConnectionManager::isConnected() const {
diff --git a/ADSL/include/ADSL/DirectiveProcessor.h b/ADSL/include/ADSL/DirectiveProcessor.h
index 174aac62..424b698f 100644
--- a/ADSL/include/ADSL/DirectiveProcessor.h
+++ b/ADSL/include/ADSL/DirectiveProcessor.h
@@ -81,7 +81,7 @@ public:
      * @param dialogRequestId The new value for the current @c dialogRequestId.
      */
     void setDialogRequestId(const std::string& dialogRequestId);
-
+   
     /**
      * Returns the @c dialogRequestId currently in use for Directive handling. This may be the empty string if
      * Directives have either experienced errors, or have been cancelled.
@@ -90,6 +90,10 @@ public:
      */
     std::string getDialogRequestId();
 
+    void setIsDialogRequestOnline(bool isOnline);
+
+    bool isDialogRequestOnline();
+
     /**
      * Queue an @c AVSDirective for handling by whatever @c DirectiveHandler was registered to handle it.
      *
@@ -192,6 +196,12 @@ private:
      */
     void processingLoop();
 
+    void setIsDialogRequestOnlineLocked(bool isOnline);
+
+    bool isDialogRequestOnlineLocked();
+
+    std::string getDialogRequestIdLocked();
+
     /**
      * Process (cancel) all the items in @c m_cancelingQueue.
      * @note This method must only be called by threads that have acquired @c m_mutex.
@@ -293,6 +303,9 @@ private:
     /// Whether or not the @c DirectiveProcessor is enabled.
     bool m_isEnabled;
 
+    /// Whether the current dialog request is from AVS (online) or AHE (offline)
+    bool m_isDialogRequestOnline;
+
     /// The current @c dialogRequestId
     std::string m_dialogRequestId;
 
diff --git a/ADSL/include/ADSL/DirectiveSequencer.h b/ADSL/include/ADSL/DirectiveSequencer.h
index d381118b..77e03340 100644
--- a/ADSL/include/ADSL/DirectiveSequencer.h
+++ b/ADSL/include/ADSL/DirectiveSequencer.h
@@ -54,6 +54,10 @@ public:
 
     std::string getDialogRequestId() override;
 
+    void setIsDialogRequestOnline(bool isOnline) override;
+
+    bool isDialogRequestOnline() override;
+
     bool onDirective(std::shared_ptr<avsCommon::avs::AVSDirective> directive) override;
 
     void disable() override;
diff --git a/ADSL/src/DirectiveProcessor.cpp b/ADSL/src/DirectiveProcessor.cpp
index fc5b484e..85acfce7 100644
--- a/ADSL/src/DirectiveProcessor.cpp
+++ b/ADSL/src/DirectiveProcessor.cpp
@@ -47,7 +47,8 @@ std::unordered_map<DirectiveProcessor::ProcessorHandle, DirectiveProcessor*> Dir
 DirectiveProcessor::DirectiveProcessor(DirectiveRouter* directiveRouter) :
         m_directiveRouter{directiveRouter},
         m_isShuttingDown{false},
-        m_isEnabled{true} {
+        m_isEnabled{true},
+        m_isDialogRequestOnline{true} {
     std::lock_guard<std::mutex> lock(m_handleMapMutex);
     m_handle = ++m_nextProcessorHandle;
     m_handleMap[m_handle] = this;
@@ -68,6 +69,16 @@ std::string DirectiveProcessor::getDialogRequestId() {
     return m_dialogRequestId;
 }
 
+void DirectiveProcessor::setIsDialogRequestOnline(bool isOnline) {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    setIsDialogRequestOnlineLocked(isOnline);
+}
+
+bool DirectiveProcessor::isDialogRequestOnline() {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    return isDialogRequestOnlineLocked();
+}
+
 bool DirectiveProcessor::onDirective(std::shared_ptr<AVSDirective> directive) {
     if (!directive) {
         ACSDK_ERROR(LX("onDirectiveFailed").d("action", "ignored").d("reason", "nullptrDirective"));
@@ -122,6 +133,18 @@ bool DirectiveProcessor::onDirective(std::shared_ptr<AVSDirective> directive) {
     return true;
 }
 
+std::string DirectiveProcessor::getDialogRequestIdLocked() {
+    return m_dialogRequestId;
+}
+
+void DirectiveProcessor::setIsDialogRequestOnlineLocked(bool isOnline) {
+    m_isDialogRequestOnline = isOnline;
+}
+
+bool DirectiveProcessor::isDialogRequestOnlineLocked() {
+    return m_isDialogRequestOnline;
+}
+
 void DirectiveProcessor::shutdown() {
     {
         std::lock_guard<std::mutex> lock(m_handleMapMutex);
diff --git a/ADSL/src/DirectiveSequencer.cpp b/ADSL/src/DirectiveSequencer.cpp
index d8c361c8..2240f09e 100644
--- a/ADSL/src/DirectiveSequencer.cpp
+++ b/ADSL/src/DirectiveSequencer.cpp
@@ -66,6 +66,14 @@ std::string DirectiveSequencer::getDialogRequestId() {
     return m_directiveProcessor->getDialogRequestId();
 }
 
+bool DirectiveSequencer::isDialogRequestOnline() {
+    return m_directiveProcessor->isDialogRequestOnline();
+}
+
+void DirectiveSequencer::setIsDialogRequestOnline(bool isOnline) {
+    m_directiveProcessor->setIsDialogRequestOnline(isOnline);
+}
+
 bool DirectiveSequencer::onDirective(std::shared_ptr<AVSDirective> directive) {
     if (!directive) {
         ACSDK_ERROR(LX("onDirectiveFailed").d("action", "ignored").d("reason", "nullptrDirective"));
diff --git a/ADSL/test/ADSL/MockDirectiveSequencer.h b/ADSL/test/ADSL/MockDirectiveSequencer.h
index 3cff6cc7..05624443 100644
--- a/ADSL/test/ADSL/MockDirectiveSequencer.h
+++ b/ADSL/test/ADSL/MockDirectiveSequencer.h
@@ -51,6 +51,10 @@ public:
         return m_dialogRequestId;
     };
 
+    MOCK_METHOD0(isDialogRequestOnline, bool());
+    
+    MOCK_METHOD1(setIsDialogRequestOnline, void(bool));
+
     MOCK_METHOD1(onDirective, bool(std::shared_ptr<avsCommon::avs::AVSDirective> directive));
 
     MOCK_METHOD0(disable, void());
diff --git a/AFML/include/AFML/FocusManager.h b/AFML/include/AFML/FocusManager.h
index 4d0cdbfe..9f013092 100644
--- a/AFML/include/AFML/FocusManager.h
+++ b/AFML/include/AFML/FocusManager.h
@@ -107,6 +107,8 @@ public:
         const std::string& channelName,
         std::shared_ptr<avsCommon::sdkInterfaces::ChannelObserverInterface> channelObserver) override;
 
+    bool releaseChannel(const std::string& channelName) override;
+
     void stopForegroundActivity() override;
 
     void stopAllActivities() override;
diff --git a/AFML/src/FocusManager.cpp b/AFML/src/FocusManager.cpp
index 4b425327..7bdec456 100644
--- a/AFML/src/FocusManager.cpp
+++ b/AFML/src/FocusManager.cpp
@@ -91,6 +91,33 @@ std::future<bool> FocusManager::releaseChannel(
     return returnValue;
 }
 
+bool FocusManager::releaseChannel(const std::string& channelName) {
+    ACSDK_DEBUG1(LX("releaseChannel").d("channelName", channelName));
+
+    std::shared_ptr<Channel> channelToRelease = getChannel(channelName);
+    if (!channelToRelease) {
+        ACSDK_ERROR(LX("releaseChannelFailed").d("reason", "channelNotFound").d("channelName", channelName));
+        return false;
+    }
+
+    auto task = [this, channelToRelease]() {
+        // Lock here to update internal state which stopForegroundActivity may concurrently access.
+        std::unique_lock<std::mutex> lock(m_mutex);
+        bool wasForegrounded = isChannelForegroundedLocked(channelToRelease);
+        m_activeChannels.erase(channelToRelease);
+        lock.unlock();
+
+        setChannelFocus(channelToRelease, FocusState::NONE);
+        if (wasForegrounded) {
+            foregroundHighestPriorityActiveChannel();
+        }
+        notifyActivityTracker();
+    };
+
+    m_executor.submit(task);
+    return true;
+}
+
 void FocusManager::stopForegroundActivity() {
     // We lock these variables so that we can correctly capture the currently foregrounded channel and activity.
     std::unique_lock<std::mutex> lock(m_mutex);
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/DialogUXStateAggregator.h b/AVSCommon/AVS/include/AVSCommon/AVS/DialogUXStateAggregator.h
index abdd5eb5..a649a0c0 100644
--- a/AVSCommon/AVS/include/AVSCommon/AVS/DialogUXStateAggregator.h
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/DialogUXStateAggregator.h
@@ -110,6 +110,12 @@ private:
      */
     void tryEnterIdleState();
 
+    /**
+     * An event has occurred which may transition @c DialogUXStateAggregator out of THINKING mode. This function
+     * evaluates if the transition is valid and performs the necessary logic to prepare for the transition.
+     */
+    void tryExitThinkingState();
+
     /**
      * Transitions the internal state from THINKING to IDLE.
      */
@@ -152,6 +158,12 @@ private:
     /// The timeout to be used for transitioning away from the THINKING state in case no messages are received.
     const std::chrono::milliseconds m_timeoutForThinkingToIdle;
 
+    /**
+     * This timeout will be used to avoid going to the IDLE state immediately after receiving a message from AVS so
+     * that other UX states (such as speech starting) may be processed and propagated.
+     */
+    const std::chrono::milliseconds m_shortTimeoutForThinkingToIdle;
+
     /// A timer to transition out of the THINKING state.
     avsCommon::utils::timing::Timer m_thinkingTimeoutTimer;
 
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/ExternalMediaPlayer/AdapterUtils.h b/AVSCommon/AVS/include/AVSCommon/AVS/ExternalMediaPlayer/AdapterUtils.h
index d16c2c95..b47bd07c 100644
--- a/AVSCommon/AVS/include/AVSCommon/AVS/ExternalMediaPlayer/AdapterUtils.h
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/ExternalMediaPlayer/AdapterUtils.h
@@ -33,7 +33,7 @@ namespace externalMediaPlayer {
 /// Enumeration class for events sent by adapters to AVS.
 enum class AdapterEvent {
     /// ChangeReport event sent after adapter's initialization succeeds/fails.
-    CHANGE_REPORT,
+    CHANGE_REPORT, // Note: not in ExternalMediaPlayer 1.1
 
     /// Event to request token from third party.
     REQUEST_TOKEN,
@@ -48,7 +48,19 @@ enum class AdapterEvent {
     PLAYER_EVENT,
 
     /// PlayerErrorEvent to report all errors from the adapters.
-    PLAYER_ERROR_EVENT
+    PLAYER_ERROR_EVENT, // Note: rename PLAYER_ERROR in ExternalMediaPlayer 1.1
+
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    /// PlayerError event to report all errors from the adapters.
+    PLAYER_ERROR,
+
+    /// ReportDiscoveredPlayers event notifies the cloud of discovered players to be authorized.
+    REPORT_DISCOVERED_PLAYERS,
+
+    /// AuthorizationComplete event notifies the cloud of players which were authorized (and de-authorized).
+    AUTHORIZATION_COMPLETE
+
+#endif
 };
 
 /// Table with the retry times on subsequent retries for session management (token fetch/changeReport send).
@@ -58,12 +70,17 @@ extern const std::vector<int> SESSION_RETRY_TABLE;
 extern avsCommon::utils::RetryTimer SESSION_RETRY_TIMER;
 
 // The NamespaceAndName for events sent from the adapter to AVS.
-extern const avsCommon::avs::NamespaceAndName CHANGE_REPORT;
+extern const avsCommon::avs::NamespaceAndName CHANGE_REPORT; // Note: not in ExternalMediaPlayer 1.1
 extern const avsCommon::avs::NamespaceAndName REQUEST_TOKEN;
 extern const avsCommon::avs::NamespaceAndName LOGIN;
 extern const avsCommon::avs::NamespaceAndName LOGOUT;
 extern const avsCommon::avs::NamespaceAndName PLAYER_EVENT;
-extern const avsCommon::avs::NamespaceAndName PLAYER_ERROR_EVENT;
+extern const avsCommon::avs::NamespaceAndName PLAYER_ERROR_EVENT; // Note: rename PLAYER_ERROR in ExternalMediaPlayer 1.1
+#ifdef EXTERNALMEDIAPLAYER_1_1
+extern const avsCommon::avs::NamespaceAndName PLAYER_ERROR; // Note: rename PLAYER_ERROR in ExternalMediaPlayer 1.1
+extern const avsCommon::avs::NamespaceAndName REPORT_DISCOVERED_PLAYERS;
+extern const avsCommon::avs::NamespaceAndName AUTHORIZATION_COMPLETE;
+#endif
 
 /**
  * Method to iterate over a collection of supported operation in playback state and convert to JSON.
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/ExternalMediaPlayer/ExternalMediaAdapterConstants.h b/AVSCommon/AVS/include/AVSCommon/AVS/ExternalMediaPlayer/ExternalMediaAdapterConstants.h
index 55320182..5e427cb1 100644
--- a/AVSCommon/AVS/include/AVSCommon/AVS/ExternalMediaPlayer/ExternalMediaAdapterConstants.h
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/ExternalMediaPlayer/ExternalMediaAdapterConstants.h
@@ -31,6 +31,15 @@ const char USERNAME[] = "username";
 const char IS_GUEST[] = "isGuest";
 const char LAUNCHED[] = "launched";
 const char ACTIVE[] = "active";
+#ifdef EXTERNALMEDIAPLAYER_1_1
+const char SPI_VERSION[] = "spiVersion";
+const char SPI_VERSION_DEFAULT[] = "1.0";
+const char PLAYER_COOKIE[] = "playerCookie";
+const char SKILL_TOKEN[] = "skillToken";
+const char PLAYBACK_SESSION_ID[] = "playbackSessionId";
+const char AGENT[] = "agent";
+const char AGENT_DEFAULT[] = "RUHAV8PRLD";
+#endif
 
 // The key values used in the context payload from External Media Player to AVS.
 const char STATE[] = "state";
diff --git a/AVSCommon/AVS/src/DialogUXStateAggregator.cpp b/AVSCommon/AVS/src/DialogUXStateAggregator.cpp
index 54d564eb..81b6a8f7 100644
--- a/AVSCommon/AVS/src/DialogUXStateAggregator.cpp
+++ b/AVSCommon/AVS/src/DialogUXStateAggregator.cpp
@@ -41,6 +41,7 @@ DialogUXStateAggregator::DialogUXStateAggregator(
     std::chrono::milliseconds timeoutForListeningToIdle) :
         m_currentState{DialogUXStateObserverInterface::DialogUXState::IDLE},
         m_timeoutForThinkingToIdle{timeoutForThinkingToIdle},
+        m_shortTimeoutForThinkingToIdle{std::chrono::milliseconds{200}},
         m_timeoutForListeningToIdle{timeoutForListeningToIdle},
         m_speechSynthesizerState{SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED},
         m_audioInputProcessorState{AudioInputProcessorObserverInterface::State::IDLE} {
@@ -120,9 +121,15 @@ void DialogUXStateAggregator::onStateChanged(SpeechSynthesizerObserverInterface:
 }
 
 void DialogUXStateAggregator::receive(const std::string& contextId, const std::string& message) {
+    tryExitThinkingState();
+}
+
+void DialogUXStateAggregator::tryExitThinkingState() {
     m_executor.submit([this]() {
         if (DialogUXStateObserverInterface::DialogUXState::THINKING == m_currentState &&
             SpeechSynthesizerObserverInterface::SpeechSynthesizerState::GAINING_FOCUS != m_speechSynthesizerState) {
+            ACSDK_DEBUG5(
+                LX("Kicking off short timer").d("shortTimeout in ms", m_shortTimeoutForThinkingToIdle.count()));
             /*
              * Stop the long timer and start a short timer so that either the state will change (i.e. Speech begins)
              * or we automatically go to idle after the short timeout (i.e. the directive received isn't related to
@@ -179,13 +186,9 @@ void DialogUXStateAggregator::onRequestProcessingStarted() {
 }
 
 void DialogUXStateAggregator::onRequestProcessingCompleted() {
-    // No-op
-    /*
-     * No particular processing is needed for this directive. The RequestProcessCompleted directive exists in the
-     * Interaction Model 1.1 to let AVS activate a logic that stops the thinking mode without any other semantic. But
-     * the specification is such that any directive will interrupt the thinking mode. So here we are simply confirming
-     * that this directive is supported.
-     */
+    // If receive() calls occur before onRequestProcessStarted() happens, we need to use this method as a fallback to
+    // exit THINKING mode.
+    tryExitThinkingState();
 }
 
 void DialogUXStateAggregator::notifyObserversOfState() {
diff --git a/AVSCommon/AVS/src/ExternalMediaPlayer/AdapterUtils.cpp b/AVSCommon/AVS/src/ExternalMediaPlayer/AdapterUtils.cpp
index 25a63664..e58d937a 100644
--- a/AVSCommon/AVS/src/ExternalMediaPlayer/AdapterUtils.cpp
+++ b/AVSCommon/AVS/src/ExternalMediaPlayer/AdapterUtils.cpp
@@ -45,12 +45,17 @@ const std::vector<int> SESSION_RETRY_TABLE = {
 
 avsCommon::utils::RetryTimer SESSION_RETRY_TIMER(SESSION_RETRY_TABLE);
 
-const NamespaceAndName CHANGE_REPORT("Alexa", "ChangeReport");
+const NamespaceAndName CHANGE_REPORT("Alexa", "ChangeReport"); // Note: not in ExternalMediaPlayer 1.1
 const NamespaceAndName REQUEST_TOKEN("ExternalMediaPlayer", "RequestToken");
 const NamespaceAndName LOGIN("ExternalMediaPlayer", "Login");
 const NamespaceAndName LOGOUT("ExternalMediaPlayer", "Logout");
 const NamespaceAndName PLAYER_EVENT("ExternalMediaPlayer", "PlayerEvent");
-const NamespaceAndName PLAYER_ERROR_EVENT("ExternalMediaPlayer", "PlayerError");
+const NamespaceAndName PLAYER_ERROR_EVENT("ExternalMediaPlayer", "PlayerError"); // Note: rename PLAYER_ERROR in ExternalMediaPlayer 1.1
+#ifdef EXTERNALMEDIAPLAYER_1_1
+const NamespaceAndName PLAYER_ERROR("ExternalMediaPlayer", "PlayerError"); // Note: rename PLAYER_ERROR in ExternalMediaPlayer 1.1
+const NamespaceAndName REPORT_DISCOVERED_PLAYERS("ExternalMediaPlayer", "ReportDiscoveredPlayers");
+const NamespaceAndName AUTHORIZATION_COMPLETE("ExternalMediaPlayer", "AuthorizationComplete");
+#endif
 
 /// The default state of a player.
 const char DEFAULT_STATE[] = "IDLE";
@@ -128,6 +133,12 @@ rapidjson::Value buildSessionState(
     playerJson.AddMember(IS_GUEST, sessionState.isGuest, allocator);
     playerJson.AddMember(LAUNCHED, sessionState.launched, allocator);
     playerJson.AddMember(ACTIVE, sessionState.active, allocator);
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    playerJson.AddMember(SPI_VERSION, sessionState.spiVersion, allocator);
+    playerJson.AddMember(PLAYER_COOKIE, sessionState.playerCookie, allocator);
+    playerJson.AddMember(SKILL_TOKEN, sessionState.skillToken, allocator);
+    playerJson.AddMember(PLAYBACK_SESSION_ID, sessionState.playbackSessionId, allocator);
+#endif
 
     return playerJson;
 }
diff --git a/AVSCommon/AVS/test/DialogUXStateAggregatorTest.cpp b/AVSCommon/AVS/test/DialogUXStateAggregatorTest.cpp
index 4c5e4396..d0f1a997 100644
--- a/AVSCommon/AVS/test/DialogUXStateAggregatorTest.cpp
+++ b/AVSCommon/AVS/test/DialogUXStateAggregatorTest.cpp
@@ -437,6 +437,23 @@ TEST_F(DialogUXAggregatorTest, test_validStatesForRPSToThinking) {
     assertNoStateChange(m_testObserver);
 }
 
+/// Test that if receive() happens before RequestProcessingCompleted directive is handled, we exit THINKING mode.
+TEST_F(DialogUXAggregatorTest, test_receiveThenRPCTransitionsOutOfThinking) {
+    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
+
+    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
+    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
+
+    m_aggregator->receive("", "");
+    m_aggregator->receive("", "");
+
+    m_aggregator->onRequestProcessingStarted();
+    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
+    m_aggregator->onRequestProcessingCompleted();
+
+    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
+}
+
 }  // namespace test
 }  // namespace avsCommon
 }  // namespace alexaClientSDK
diff --git a/AVSCommon/CMakeLists.txt b/AVSCommon/CMakeLists.txt
index d10b8ccd..20698fcb 100644
--- a/AVSCommon/CMakeLists.txt
+++ b/AVSCommon/CMakeLists.txt
@@ -54,6 +54,8 @@ add_library(AVSCommon SHARED
     Utils/src/LibcurlUtils/HTTPContentFetcherFactory.cpp
     Utils/src/LibcurlUtils/HttpPost.cpp
     Utils/src/LibcurlUtils/HttpPut.cpp
+    Utils/src/LibcurlUtils/HttpGet.cpp
+    Utils/src/LibcurlUtils/HttpDelete.cpp
     Utils/src/LibcurlUtils/HTTPResponse.cpp
     Utils/src/LibcurlUtils/LibCurlHttpContentFetcher.cpp
     Utils/src/LibcurlUtils/LibcurlHTTP2Connection.cpp
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/CallStateObserverInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/CallStateObserverInterface.h
index fc8e7cd8..118e5f17 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/CallStateObserverInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/CallStateObserverInterface.h
@@ -41,17 +41,30 @@ public:
         NONE
     };
 
+    /// Information about the call to display on screen-based devices when the observer is notified of a call state change.
+    struct CallDisplayInfo {
+        /// The contact name to be displayed.
+        std::string displayName;
+        /// Information about the endpoint of the contact (work/mobile/home etc.).
+        std::string endpointLabel;
+        /// Contains name of callee for whom incoming call is intended. This field is not populated for Alexa/Skype calls currently.
+        std::string inboundCalleeName;
+        /// Textual description of exact call provider type (e.g. "Alexa Call", "Skype Call" etc.).
+        std::string callProviderType;
+    };
+
     /**
      * Destructor
      */
     virtual ~CallStateObserverInterface() = default;
 
     /**
-     * Allows the observer to react to a change in call state.
+     * Allows the observer to react to a change in call state with display info for the call.
      *
      * @param state The new CallState.
+     * @param displayInfo Information to be used for display on screen-based devices.
      */
-    virtual void onCallStateChange(CallState state) = 0;
+    virtual void onCallStateChange(CallState state, const CallDisplayInfo& displayInfo) = 0;
 };
 
 /**
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h
index cd12ecef..5e482991 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h
@@ -97,6 +97,10 @@ public:
      */
     virtual std::string getDialogRequestId() = 0;
 
+    virtual void setIsDialogRequestOnline(bool isOnline) = 0;
+
+    virtual bool isDialogRequestOnline() = 0;
+
     /**
      * Sequence the handling of an @c AVSDirective.  The actual handling is done by whichever @c DirectiveHandler
      * is associated with the most specific routing rule.
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalMediaAdapterHandlerInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalMediaAdapterHandlerInterface.h
new file mode 100644
index 00000000..20d26e33
--- /dev/null
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalMediaAdapterHandlerInterface.h
@@ -0,0 +1,126 @@
+/*
+ * Copyright 2017-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_EXTERNALMEDIAADAPTERHANDLERINTERFACE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_EXTERNALMEDIAADAPTERHANDLERINTERFACE_H_
+
+#include <chrono>
+#include <string>
+#include <vector>
+
+#include "AVSCommon/SDKInterfaces/ExternalMediaAdapterInterface.h"
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace sdkInterfaces {
+
+/**
+ * The ExternalMediaAdapterHandlerInterface class provides generic ExternalMediaPlayer 1.1 Interface support
+ * for extending functionality to custom handlers for managing multi player adapters as required by MACC.
+ * Note: This interface may eventually be replaced with integrated support for multi player adapters.
+ */
+class ExternalMediaAdapterHandlerInterface {
+public:
+    /**
+     * Destructor
+     */
+    virtual ~ExternalMediaAdapterHandlerInterface() = default;
+
+    /**
+     * Method to handle the ExternalMediaPlayer AuthorizeDiscoveredPlayers directive.
+     *
+     * @param payload The AuthorizeDiscoveredPlayers directive payload.
+     *
+     * @note With multiple adapter handlers, playerId can belong to another adapter handler.
+     */
+    virtual void authorizeDiscoveredPlayers(const std::string& payload) = 0;
+
+    /**
+     * Method to handle the ExternalMediaPlayer Login directive.
+     *
+     * @param payload The Login directive payload.
+     *
+     * @note With multiple adapter handlers, playerId can belong to another adapter handler.
+     */
+    virtual void login(const std::string& payload) = 0;
+
+    /**
+     * Method to handle the ExternalMediaPlayer Logout directive.
+     *
+     * @param payload The Logout directive payload.
+     *
+     * @note With multiple adapter handlers, playerId can belong to another adapter handler.
+     */
+    virtual void logout(const std::string& payload) = 0;
+
+    /**
+     * Method to handle the ExternalMediaPlayer Play directive.
+     *
+     * @param payload The Play directive payload.
+     *
+     * @note With multiple adapter handlers, playerId can belong to another adapter handler.
+     */
+    virtual void play(const std::string& payload) = 0;
+
+    /**
+     * Method to handle the Alexa.PlaybackController Play/Pause/Next/Previous/StartOver/Rewind/FastForward directives.
+     *
+     * @param payload The Play/Pause/Next/Previous/StartOver/Rewind/FastForward directive payload.
+     * @param requestType The external media player request type.
+     *
+     * @note With multiple adapter handlers, playerId can belong to another adapter handler.
+     */
+    virtual void playControl(const std::string& payload, alexaClientSDK::avsCommon::sdkInterfaces::externalMediaPlayer::RequestType requestType) = 0;
+
+    /**
+     * Method to handle the Alexa.PlaybackController Play/Pause/Next/Previous/StartOver/Rewind/FastForward directives for a designated player (i.e. the player in focus).
+     *
+     * @param payload The Play/Pause/Next/Previous/StartOver/Rewind/FastForward directive payload.
+     * @param requestType The external media player request type.
+     *
+     * @note Handles PlaybackHandlerInterface onTogglePressed() and onButtonPressed() notifications for the player in focus.
+     * @note With multiple adapter handlers, playerId can belong to another adapter handler.
+     */
+    virtual void playControlForPlayer(const std::string& playerId, alexaClientSDK::avsCommon::sdkInterfaces::externalMediaPlayer::RequestType requestType) = 0;
+
+    /**
+     * Method to handle the Alexa.SeekController SetSeekPosition directive.
+     *
+     * @param payload The SetSeekPosition directive payload.
+     *
+     * @note With multiple adapter handlers, playerId can belong to another adapter handler.
+     */
+    virtual void seek(const std::string& payload) = 0;
+
+    /**
+     * Method to handle the Alexa.SeekController AdjustSeekPosition directive.
+     *
+     * @param payload The AdjustSeekPosition directive payload.
+     *
+     * @note With multiple adapter handlers, playerId can belong to another adapter handler.
+     */
+    virtual void adjustSeek(const std::string& payload) = 0;
+
+    /**
+     * Method to get adapter state for each of the handled players.
+     */
+    virtual std::vector<avsCommon::sdkInterfaces::externalMediaPlayer::AdapterState> getAdapterStates() = 0;
+};
+
+}  // namespace sdkInterfaces
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_EXTERNALMEDIAADAPTERHANDLERINTERFACE_H_
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalMediaAdapterInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalMediaAdapterInterface.h
index d100866c..dc378e40 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalMediaAdapterInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalMediaAdapterInterface.h
@@ -267,6 +267,21 @@ struct AdapterSessionState {
      */
     bool active;
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    /// The service provider interface (SPI) version.
+    std::string spiVersion;
+
+    /// The playerCookie to select version-specific content or actions.
+    std::string playerCookie;
+
+    /// An opaque token for the domain or skill that is presently associated with this player.
+    std::string skillToken;
+
+    /// A universally unique identifier (UUID) generated to the RFC 4122 specification.
+    std::string playbackSessionId;
+
+#endif
+
     /**
      * The accessToken used to login a user. The access token may also be used as a bearer token if the adapter
      * makes an authenticated Web API to the music provider.
@@ -425,6 +440,26 @@ public:
      */
     virtual void handleLogout() = 0;
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    /**
+     * Method to allow a user to initiate play from a third party music service provider based on a play context.
+     *
+     * @param playContextToken Play context {Track/playlist/album/artist/station/podcast} identifier.
+     * @param index The index of the media item in the container, if the container is indexable.
+     * @param offset The offset position within media item, in milliseconds.
+     * @param skillToken An opaque token for the domain or skill that is presently associated with this player.
+     * @param playbackSessionId A universally unique identifier (UUID) generated to the RFC 4122 specification.
+     * @param navigation Communicates desired visual display behavior for the app associated with playback.
+     * @param preload If true, this Play directive is intended to preload the identified content only but not begin playback.
+     */
+    virtual void handlePlay(std::string& playContextToken,
+                            int64_t index,
+                            std::chrono::milliseconds offset,
+                            std::string& skillToken,
+                            std::string& playbackSessionId,
+                            std::string& navigation, // DEFAULT, NONE, FOREGROUND
+                            bool preload) = 0;
+#else
     /**
      * Method to allow a user to initiate play from a third party music service provider based on a play context.
      *
@@ -433,6 +468,7 @@ public:
      * @param offset The offset position within media item, in milliseconds.
      */
     virtual void handlePlay(std::string& playContextToken, int64_t index, std::chrono::milliseconds offset) = 0;
+#endif
 
     /**
      * Method to initiate the different types of play control like PLAY/PAUSE/RESUME/NEXT/...
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalMediaPlayerInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalMediaPlayerInterface.h
index 862df746..728ca2bc 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalMediaPlayerInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalMediaPlayerInterface.h
@@ -16,6 +16,9 @@
 #ifndef ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_EXTERNALMEDIAPLAYERINTERFACE_H_
 #define ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_EXTERNALMEDIAPLAYERINTERFACE_H_
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+#include <AVSCommon/AVS/PlayerActivity.h>
+#endif
 #include <AVSCommon/SDKInterfaces/ContextManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/FocusManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/MessageSenderInterface.h>
@@ -30,7 +33,8 @@ namespace sdkInterfaces {
 
 /**
  * This class provides an interface to the @c ExternalMediaPlayer.
- * Currently it provides an interface for adapters to set the player in focus when they acquire focus.
+ * Currently it provides an interface for adapters to set the current activity
+ * and set the player in focus when they acquire focus.
  */
 class ExternalMediaPlayerInterface {
 public:
@@ -39,6 +43,24 @@ public:
      */
     virtual ~ExternalMediaPlayerInterface() = default;
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    /**
+     * Method to set the current activity for the player in focus.
+     *
+     * @param currentActivity The current activity of the player.
+     */
+    virtual void setCurrentActivity(const avsCommon::avs::PlayerActivity currentActivity) = 0;
+
+    /**
+     * Method to set the player in focus after an adapter has acquired the channel.
+     *
+     * @param playerInFocus The business name of the adapter that has currently acquired focus.
+     * @param focusAcquire If @c true, acquire the channel and manage the focus state.
+     * If @c false release the channel when the player is the player in focus.
+     */
+    virtual void setPlayerInFocus(const std::string& playerInFocus, bool focusAcquire) = 0;
+#endif
+
     /**
      * Method to set the player in focus after an adapter has acquired the channel.
      *
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/FocusManagerInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/FocusManagerInterface.h
index fc550ebc..b92aba53 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/FocusManagerInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/FocusManagerInterface.h
@@ -114,6 +114,17 @@ public:
         const std::string& channelName,
         std::shared_ptr<avsCommon::sdkInterfaces::ChannelObserverInterface> channelObserver) = 0;
 
+    /**
+     * This method will release the Channel without specifying the observer and notify the current observer of the 
+     * Channel to stop via ChannelObserverInterface##onFocusChanged(). If the Channel to release is the current 
+     * foreground focused Channel, it will also notify the next highest priority Channel via a 
+     * ChannelObserverInterface##onFocusChanged() callback that it has gained foreground focus.
+     *
+     * @param channelName The name of the Channel to release.
+     * @return Returns @c true if the Channel can be released and @c false otherwise.
+     */
+    virtual bool releaseChannel(const std::string& channelName) = 0;    
+
     /**
      * This method will request that the currently foregrounded Channel activity be stopped, if there is one. This will
      * be performed asynchronously, and so, if at the time of processing, the activity has stopped for any reason, then
diff --git a/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockDirectiveSequencer.h b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockDirectiveSequencer.h
index 263e0252..680d6e11 100644
--- a/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockDirectiveSequencer.h
+++ b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockDirectiveSequencer.h
@@ -37,6 +37,10 @@ public:
     inline std::string getDialogRequestId() {
         return m_dialogRequestId;
     };
+	
+	MOCK_METHOD0(isDialogRequestOnline, bool());
+    MOCK_METHOD1(setIsDialogRequestOnline, void(bool));
+	
     MOCK_METHOD1(onDirective, bool(std::shared_ptr<avsCommon::avs::AVSDirective> directive));
     MOCK_METHOD0(doShutdown, void());
     MOCK_METHOD0(disable, void());
diff --git a/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockFocusManager.h b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockFocusManager.h
index c2404fe9..507c6136 100644
--- a/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockFocusManager.h
+++ b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockFocusManager.h
@@ -39,6 +39,7 @@ public:
             const std::string& channelName,
             std::shared_ptr<avsCommon::sdkInterfaces::ChannelObserverInterface> channelObserver));
     MOCK_METHOD0(stopForegroundActivity, void());
+    MOCK_METHOD1(releaseChannel, bool(const std::string& channelName));
     MOCK_METHOD1(
         addObserver,
         void(const std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerObserverInterface>& observer));
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h
index 72a78344..beb9cd7d 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h
@@ -73,7 +73,9 @@ public:
         /// HTTP POST
         kPOST,
         /// HTTP PUT
-        kPUT
+        kPUT,
+        /// HTTP DELETE
+        kDELETE
     };
 
     /**
@@ -254,6 +256,23 @@ public:
      */
     CURLcode pause(int mask);
 
+    /**
+     * Static function to set the network interface for the curl.
+     *
+     * Inteface provided will be used in preference over the
+     * value in provided in config.
+     *
+     * @param value The interface name as defined in CURLOPT_INTERFACE.
+     */
+    static void setInterfaceName( const std::string& interfaceName );
+
+     /**
+     * Static function to get the network interface set using
+     * the @setInterfaceName.
+     *
+     * @returns the network interface set otherwise empty string.
+     */
+    static std::string getInterfaceName();
 private:
     /**
      * Frees and sets the following attributes to NULL:
@@ -312,7 +331,8 @@ private:
     curl_httppost* m_lastPost;
     /// Name for this handle.
     std::string m_id;
-
+    /// Interface name to be used for curl
+    static std::string m_interfaceName;
     /// If no id is provided by the user, we will generate it from this counter.
     static std::atomic<uint64_t> m_idGenerator;
 };
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h
new file mode 100644
index 00000000..0bfbaa19
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETE_H_
+
+#include <memory>
+#include <mutex>
+#include <string>
+
+#include <curl/curl.h>
+
+#include "AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h"
+#include "HttpDeleteInterface.h"
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// LIBCURL based implementation of HttpDeleteInterface.
+class HttpDelete : public HttpDeleteInterface {
+public:
+    /**
+     * Create a new HttpDelete instance, passing ownership of the new instance on to the caller.
+     *
+     * @return Returns an std::unique_ptr to the new HttpDelete instance, or @c nullptr of the operation failed.
+     */
+    static std::unique_ptr<HttpDelete> create();
+
+    /**
+     * HttpDelete destructor
+     */
+    ~HttpDelete() = default;
+
+    /**
+     * Deleted copy constructor.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     */
+    HttpDelete(const HttpDelete& rhs) = delete;
+
+    /**
+     * Deleted assignment operator.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     * @return The object assigned to.
+     */
+    HttpDelete& operator=(const HttpDelete& rhs) = delete;
+
+    HTTPResponse doDelete(const std::string& url, const std::vector<std::string>& headers) override;
+
+private:
+    /**
+     * Default HttpDelete constructor.
+     */
+    HttpDelete() = default;
+
+    /// Mutex to serialize access to @c m_curl.
+    std::mutex m_mutex;
+
+    /// CURL handle with which to make requests
+    CurlEasyHandleWrapper m_curl;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETE_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h
new file mode 100644
index 00000000..1a948d8b
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETEINTERFACE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETEINTERFACE_H_
+
+#include <string>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/HTTPResponse.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// Minimal interface for making HTTP DELETE requests.
+class HttpDeleteInterface {
+public:
+    /// Virtual destructor to assure proper cleanup of derived types.
+    virtual ~HttpDeleteInterface() = default;
+
+    /**
+     * Perform an HTTP DELETE request returning the response body as a string. This method blocks for the duration
+     * of the request.
+     *
+     * @param url The URL to send the DELETE to.
+     * @param headers vector of strings to add in the header.
+     * @return An object describing the response to the DELETE request.
+     */
+    virtual HTTPResponse doDelete(
+        const std::string& url,
+        const std::vector<std::string>& headers) = 0;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETEINTERFACE_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h
new file mode 100644
index 00000000..50685028
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGET_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGET_H_
+
+#include <memory>
+#include <mutex>
+#include <string>
+
+#include <curl/curl.h>
+
+#include "AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h"
+#include "HttpGetInterface.h"
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// LIBCURL based implementation of HttpGetInterface.
+class HttpGet : public HttpGetInterface {
+public:
+    /**
+     * Create a new HttpGet instance, passing ownership of the new instance on to the caller.
+     *
+     * @return Returns an std::unique_ptr to the new HttpGet instance, or @c nullptr of the operation failed.
+     */
+    static std::unique_ptr<HttpGet> create();
+
+    /**
+     * HttpGet destructor
+     */
+    ~HttpGet() = default;
+
+    /**
+     * Deleted copy constructor.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     */
+    HttpGet(const HttpGet& rhs) = delete;
+
+    /**
+     * Deleted assignment operator.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     * @return The object assigned to.
+     */
+    HttpGet& operator=(const HttpGet& rhs) = delete;
+
+    HTTPResponse doGet(const std::string& url, const std::vector<std::string>& headers) override;
+
+private:
+    /**
+     * Default HttpGet constructor.
+     */
+    HttpGet() = default;
+
+    /// Mutex to serialize access to @c m_curl.
+    std::mutex m_mutex;
+
+    /// CURL handle with which to make requests
+    CurlEasyHandleWrapper m_curl;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGET_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h
new file mode 100644
index 00000000..770b206b
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGETINTERFACE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGETINTERFACE_H_
+
+#include <string>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/HTTPResponse.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// Minimal interface for making HTTP GET requests.
+class HttpGetInterface {
+public:
+    /// Virtual destructor to assure proper cleanup of derived types.
+    virtual ~HttpGetInterface() = default;
+
+    /**
+     * Perform an HTTP Get request returning the response body as a string. This method blocks for the duration
+     * of the request.
+     *
+     * @param url The URL to send the GET to.
+     * @param headers vector of strings to add in the header.
+     * @return An object describing the response to the GET request.
+     */
+    virtual HTTPResponse doGet(
+        const std::string& url,
+        const std::vector<std::string>& headers) = 0;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGETINTERFACE_H_
diff --git a/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp b/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp
index c3bda8f8..df104c01 100644
--- a/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp
+++ b/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp
@@ -54,7 +54,8 @@ static const std::string LIBCURLUTILS_CONFIG_KEY = "libcurlUtils";
 static const std::string INTERFACE_CONFIG_KEY = "CURLOPT_INTERFACE";
 /// Counter used to geneate unique IDs.
 std::atomic<uint64_t> CurlEasyHandleWrapper::m_idGenerator{1};
-
+///  Interface used for the curl connection.
+std::string CurlEasyHandleWrapper::m_interfaceName{""};
 #ifdef ACSDK_EMIT_CURL_LOGS
 /// Key under 'acl' configuration node for path/prefix of per-stream log file names.
 static const std::string STREAM_LOG_PREFIX_KEY("streamLogPrefix");
@@ -242,6 +243,9 @@ bool CurlEasyHandleWrapper::setTransferType(TransferType type) {
         case TransferType::kPUT:
             ret = setopt(CURLOPT_UPLOAD, 1L);
             break;
+        case TransferType::kDELETE:
+            ret = setopt(CURLOPT_CUSTOMREQUEST, "DELETE");
+            break;
     }
     return ret;
 }
@@ -324,7 +328,14 @@ bool CurlEasyHandleWrapper::setDefaultOptions() {
 
         auto config = configuration::ConfigurationNode::getRoot()[LIBCURLUTILS_CONFIG_KEY];
         std::string interfaceName;
-        if (config.getString(INTERFACE_CONFIG_KEY, &interfaceName) &&
+        config.getString(INTERFACE_CONFIG_KEY, &interfaceName, "");
+
+        if (!m_interfaceName.empty()) {
+            // Override the config, if interface name is provided at runtime. 
+            interfaceName = m_interfaceName;
+        }
+
+        if (!interfaceName.empty() &&
             !setopt(CURLOPT_INTERFACE, interfaceName.c_str())) {
             break;
         }
@@ -372,6 +383,14 @@ CURLcode CurlEasyHandleWrapper::pause(int mask) {
     return CURLcode::CURLE_FAILED_INIT;
 }
 
+void CurlEasyHandleWrapper::setInterfaceName( const std::string& interfaceName ) {
+    m_interfaceName = interfaceName;
+}
+
+std::string CurlEasyHandleWrapper::getInterfaceName() {
+    return m_interfaceName;
+}
+
 #ifdef ACSDK_EMIT_CURL_LOGS
 void CurlEasyHandleWrapper::initStreamLog() {
     std::string streamLogPrefix;
diff --git a/AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp b/AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp
new file mode 100644
index 00000000..b41bace0
--- /dev/null
+++ b/AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <cstdlib>
+#include <cstring>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/CallbackData.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpDelete.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+using namespace alexaClientSDK::avsCommon::utils;
+
+/// String to identify log entries originating from this file.
+static const std::string TAG("HttpDelete");
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+/**
+ * Write callback function used for CURLOPT_WRITEFUNCTION option in libcurl
+ */
+static size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream);
+
+std::unique_ptr<HttpDelete> HttpDelete::create() {
+    std::unique_ptr<HttpDelete> httpDelete(new HttpDelete());
+    if (httpDelete->m_curl.isValid()) {
+        return httpDelete;
+    }
+    return nullptr;
+}
+
+HTTPResponse HttpDelete::doDelete(const std::string& url, const std::vector<std::string>& headers ) {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    const std::string errorEvent = "doDeleteFailed";
+    const std::string errorReasonKey = "reason";
+    HTTPResponse httpResponse;
+
+    if (!m_curl.reset()) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToResetCurlHandle"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setURL(url)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetUrl"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setTransferType(CurlEasyHandleWrapper::TransferType::kDELETE)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetHttpRequestType"));
+        return httpResponse;
+    }
+
+    for (auto header : headers) {
+        if (!m_curl.addHTTPHeader(header)) {
+            ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToAddHttpHeader"));
+            return httpResponse;
+        }
+    }
+
+    CallbackData responseData;
+    if (!m_curl.setWriteCallback(writeCallback, &responseData)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetWriteCallback"));
+        return httpResponse;
+    }
+
+    CURLcode curlResult = m_curl.perform();
+    if (curlResult != CURLE_OK) {
+        ACSDK_ERROR(
+            LX(errorEvent).d(errorReasonKey, "curlFailedWithCode: " + std::string(curl_easy_strerror(curlResult))));
+        return httpResponse;
+    }
+
+    size_t responseSize = responseData.getSize();
+    if (responseSize > 0) {
+        std::vector<char> responseBody(responseSize + 1, 0);
+        responseData.getData(responseBody.data(), responseSize);
+        httpResponse.body = std::string(responseBody.data());
+    } else {
+        httpResponse.body = "";
+    }
+    httpResponse.code = m_curl.getHTTPResponseCode();
+
+    return httpResponse;
+}
+
+size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream) {
+    if (!dataStream) {
+        ACSDK_ERROR(LX("writeCallbackFailed").d("reason", "nullDataStream"));
+        return 0;
+    }
+
+    size_t realSize = blockSize * numBlocks;
+    CallbackData* callbackData = reinterpret_cast<CallbackData*>(dataStream);
+
+    return callbackData->appendData(dataBuffer, realSize);
+}
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp b/AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp
new file mode 100644
index 00000000..ee45dfd6
--- /dev/null
+++ b/AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <cstdlib>
+#include <cstring>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/CallbackData.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpGet.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+using namespace alexaClientSDK::avsCommon::utils;
+
+/// String to identify log entries originating from this file.
+static const std::string TAG("HttpGet");
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+/**
+ * Write callback function used for CURLOPT_WRITEFUNCTION option in libcurl
+ */
+static size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream);
+
+std::unique_ptr<HttpGet> HttpGet::create() {
+    std::unique_ptr<HttpGet> httpGet(new HttpGet());
+    if (httpGet->m_curl.isValid()) {
+        return httpGet;
+    }
+    return nullptr;
+}
+
+HTTPResponse HttpGet::doGet(const std::string& url, const std::vector<std::string>& headers ) {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    const std::string errorEvent = "doGetFailed";
+    const std::string errorReasonKey = "reason";
+    HTTPResponse httpResponse;
+
+    if (!m_curl.reset()) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToResetCurlHandle"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setURL(url)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetUrl"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setTransferType(CurlEasyHandleWrapper::TransferType::kGET)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetHttpRequestType"));
+        return httpResponse;
+    }
+
+    for (auto header : headers) {
+        if (!m_curl.addHTTPHeader(header)) {
+            ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToAddHttpHeader"));
+            return httpResponse;
+        }
+    }
+
+    CallbackData responseData;
+    if (!m_curl.setWriteCallback(writeCallback, &responseData)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetWriteCallback"));
+        return httpResponse;
+    }
+
+    CURLcode curlResult = m_curl.perform();
+    if (curlResult != CURLE_OK) {
+        ACSDK_ERROR(
+            LX(errorEvent).d(errorReasonKey, "curlFailedWithCode: " + std::string(curl_easy_strerror(curlResult))));
+        return httpResponse;
+    }
+
+    size_t responseSize = responseData.getSize();
+    if (responseSize > 0) {
+        std::vector<char> responseBody(responseSize + 1, 0);
+        responseData.getData(responseBody.data(), responseSize);
+        httpResponse.body = std::string(responseBody.data());
+    } else {
+        httpResponse.body = "";
+    }
+    httpResponse.code = m_curl.getHTTPResponseCode();
+
+    return httpResponse;
+}
+
+size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream) {
+    if (!dataStream) {
+        ACSDK_ERROR(LX("writeCallbackFailed").d("reason", "nullDataStream"));
+        return 0;
+    }
+
+    size_t realSize = blockSize * numBlocks;
+    CallbackData* callbackData = reinterpret_cast<CallbackData*>(dataStream);
+
+    return callbackData->appendData(dataBuffer, realSize);
+}
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/ApplicationUtilities/DefaultClient/src/DefaultClient.cpp b/ApplicationUtilities/DefaultClient/src/DefaultClient.cpp
index 1b29073a..7295d86b 100644
--- a/ApplicationUtilities/DefaultClient/src/DefaultClient.cpp
+++ b/ApplicationUtilities/DefaultClient/src/DefaultClient.cpp
@@ -694,6 +694,7 @@ bool DefaultClient::initialize(
         contextManager,
         m_exceptionSender,
         m_playbackRouter,
+        m_certifiedSender,
         m_captionManager);
 #else
     m_audioPlayer = capabilityAgents::audioPlayer::AudioPlayer::create(
@@ -703,6 +704,7 @@ bool DefaultClient::initialize(
         contextManager,
         m_exceptionSender,
         m_playbackRouter,
+        m_certifiedSender,
         nullptr);
 #endif
     if (!m_audioPlayer) {
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 7b2de617..a431dcd2 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -6,6 +6,10 @@ set(PROJECT_BRIEF "A cross-platform, modular SDK for interacting with the Alexa
 if (EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/CapabilityAgents/ExternalMediaPlayer/src/ExternalMediaPlayerAdapters")
     set(HAS_EXTERNAL_MEDIA_PLAYER_ADAPTERS ON)
 endif()
+option(EXTERNALMEDIAPLAYER_1_1 "Build ExternalMediaPlayer 1.1" ON)
+if(EXTERNALMEDIAPLAYER_1_1)
+    add_definitions(-DEXTERNALMEDIAPLAYER_1_1)
+endif()
 
 include(build/BuildDefaults.cmake)
 include(tools/Testing.cmake)
diff --git a/CapabilityAgents/Alerts/include/Alerts/AlertObserverInterface.h b/CapabilityAgents/Alerts/include/Alerts/AlertObserverInterface.h
index af0ff6ac..780ffce2 100644
--- a/CapabilityAgents/Alerts/include/Alerts/AlertObserverInterface.h
+++ b/CapabilityAgents/Alerts/include/Alerts/AlertObserverInterface.h
@@ -74,6 +74,29 @@ public:
         State state,
         const std::string& reason = "") = 0;
 
+    /**
+     * A callback function to notify an object that an alert has been created with additional information about the alert.
+     *
+     * @param alertToken The AVS token of the alert.
+     * @param detailedInfo The JSON payload of detailed alert info :
+     * {
+     *      "time" : <String>
+     *      "type" : <String>
+     *      "label" : <String>
+     * }
+     * time The time string ( Scheduled Time ISO_8601 ).
+     * type The type of the alert ( ALERT, REMINDER, TIMER ).
+     * label The label of the TIMER, description for REMINDER, or empty string for ALARM.
+     */
+    virtual void onAlertCreated(const std::string& alertToken, const std::string& detailedInfo) {};
+
+    /**
+     * A callback function to notify an object that an alert has been deleted.
+     *
+     * alertToken The AVS token of the alert.
+     */
+    virtual void onAlertDeleted(const std::string& alertToken) {};
+
     /**
      * Convert a @c State to a @c std::string.
      *
diff --git a/CapabilityAgents/Alerts/include/Alerts/AlertsCapabilityAgent.h b/CapabilityAgents/Alerts/include/Alerts/AlertsCapabilityAgent.h
index 8c7b9cf4..74de4cab 100644
--- a/CapabilityAgents/Alerts/include/Alerts/AlertsCapabilityAgent.h
+++ b/CapabilityAgents/Alerts/include/Alerts/AlertsCapabilityAgent.h
@@ -288,6 +288,32 @@ private:
         AlertObserverInterface::State state,
         const std::string& reason);
 
+    /**
+     * A callback function to notify an object that an alert has been created with additional information about the alert.
+     *
+     * @param alertToken The AVS token of the alert.
+     * @param detailedInfo The JSON payload of detailed alert info :
+     * {
+     *      "time" : <String>
+     *      "type" : <String>
+     *      "label" : <String>
+     * }
+     * time The time string ( Scheduled Time ISO_8601 ).
+     * type The type of the alert ( ALERT, REMINDER, TIMER ).
+     * label The label of the TIMER, description for REMINDER, or empty string for ALARM.
+     */
+    void executeOnAlertCreated(
+        const std::string& alertToken,
+        const std::string& jsonPayload);
+
+    /**
+     * A handler function which will be called by our internal executor when an alert is deleted.
+     *
+     * alertToken The AVS token of the alert.
+     */
+    void executeOnAlertDeleted(
+        const std::string& alertToken);
+
     /**
      * A handler function which will be called by our internal executor to add an alert observer.
      *
@@ -316,6 +342,21 @@ private:
         AlertObserverInterface::State state,
         const std::string& reason = "");
 
+    /**
+     * A handler function which will be called by our internal executor to notify the observer of detailed alert info.
+     *
+     * @param alertToken The alert token. See AlertObserverInterface for more.
+     * @param jsonInfo The detailed JSON info. See AlertObserverInterface for more.
+     */
+    void executeNotifyAlertCreatedObservers(const std::string& alertToken, const std::string& jsonInfo);
+
+    /**
+     * A handler function which will be called by our internal executor to notify the observer of an alert deleted.
+     *
+     * @param alertToken The alert token. See AlertObserverInterface for more.
+     */
+    void executeNotifyAlertDeletedObservers(const std::string& alertToken);
+
     /**
      * A handler function which will be called by our internal executor to remove all alerts currently being managed.
      */
diff --git a/CapabilityAgents/Alerts/src/AlertsCapabilityAgent.cpp b/CapabilityAgents/Alerts/src/AlertsCapabilityAgent.cpp
index 37f35357..34fa86f7 100644
--- a/CapabilityAgents/Alerts/src/AlertsCapabilityAgent.cpp
+++ b/CapabilityAgents/Alerts/src/AlertsCapabilityAgent.cpp
@@ -66,6 +66,9 @@ static const std::string ALERTS_CAPABILITY_INTERFACE_VERSION = "1.4";
 /// The value for Type which we need for json parsing.
 static const std::string KEY_TYPE = "type";
 
+/// The value for Label which we need for json parsing.
+static const std::string KEY_LABEL = "label";
+
 // ==== Directives ===
 
 /// The value of the SetAlert Directive.
@@ -524,6 +527,27 @@ bool AlertsCapabilityAgent::handleSetAlert(
 
     updateContextManager();
 
+    Document document( rapidjson::kObjectType );
+    document.AddMember("time", parsedAlert->getScheduledTime_ISO_8601(), document.GetAllocator());
+    document.AddMember("type", parsedAlert->getTypeName(), document.GetAllocator());
+    std::string label;
+    if (!retrieveValue(payload, KEY_LABEL, &label)) {
+        document.AddMember("label", "", document.GetAllocator());
+    } else {
+        document.AddMember("label", label, document.GetAllocator());
+    }
+    // build the json state string
+    rapidjson::StringBuffer buffer;
+    rapidjson::Writer<rapidjson::StringBuffer> writer( buffer );
+
+    if (!document.Accept( writer )) {
+        ACSDK_ERROR(LX("failedToWriteJsonDocument").m("Alert DetailedInfo not sent"));
+    } else {
+        std::string payload = buffer.GetString();
+        std::string token = parsedAlert->getToken();
+        m_executor.submit([this, token, payload]() { executeOnAlertCreated( token, payload); });
+    }
+
     return true;
 }
 
@@ -543,6 +567,9 @@ bool AlertsCapabilityAgent::handleDeleteAlert(
 
     updateContextManager();
 
+    std::string token = *alertToken;
+    m_executor.submit([this, token]() { executeOnAlertDeleted(token); });
+
     return true;
 }
 
@@ -572,6 +599,8 @@ bool AlertsCapabilityAgent::handleDeleteAlerts(
         if (!convertToValue(tokenArray[i], &token)) {
             ACSDK_WARN(LX("handleDeleteAlertsFailed").d("reason", "invalid token in payload"));
             continue;
+        } else {
+            m_executor.submit([this, token]() { executeOnAlertDeleted(token); });
         }
         alertTokens.push_back(token);
     }
@@ -936,6 +965,14 @@ void AlertsCapabilityAgent::executeOnAlertStateChange(
     });
 }
 
+void AlertsCapabilityAgent::executeOnAlertCreated(const std::string& alertToken, const std::string& payload){
+    m_executor.submit([this, alertToken, payload]() { executeNotifyAlertCreatedObservers(alertToken, payload); });
+}
+
+void AlertsCapabilityAgent::executeOnAlertDeleted(const std::string& alertToken){
+    m_executor.submit([this, alertToken]() { executeNotifyAlertDeletedObservers(alertToken); });
+}
+
 void AlertsCapabilityAgent::executeAddObserver(std::shared_ptr<AlertObserverInterface> observer) {
     ACSDK_DEBUG1(LX("executeAddObserver").d("observer", observer.get()));
     m_observers.insert(observer);
@@ -961,6 +998,23 @@ void AlertsCapabilityAgent::executeNotifyObservers(
     }
 }
 
+void AlertsCapabilityAgent::executeNotifyAlertCreatedObservers(
+    const std::string& alertToken,
+    const std::string& payload) {
+        ACSDK_DEBUG1(LX("executeNotifyAlertCreatedObservers").d("alertToken", alertToken).sensitive("payload", payload));
+    for (auto observer : m_observers) {
+        observer->onAlertCreated(alertToken, payload);
+    }
+}
+
+void AlertsCapabilityAgent::executeNotifyAlertDeletedObservers(
+    const std::string& alertToken) {
+        ACSDK_DEBUG1(LX("executeNotifyAlertDeletedObservers").d("alertToken", alertToken));
+    for (auto observer : m_observers) {
+        observer->onAlertDeleted(alertToken);
+    }
+}
+
 void AlertsCapabilityAgent::executeRemoveAllAlerts() {
     ACSDK_DEBUG1(LX("executeRemoveAllAlerts"));
     m_alertScheduler.clearData();
diff --git a/CapabilityAgents/AudioPlayer/include/AudioPlayer/AudioPlayer.h b/CapabilityAgents/AudioPlayer/include/AudioPlayer/AudioPlayer.h
index 49df3c9e..feb7d9e8 100644
--- a/CapabilityAgents/AudioPlayer/include/AudioPlayer/AudioPlayer.h
+++ b/CapabilityAgents/AudioPlayer/include/AudioPlayer/AudioPlayer.h
@@ -42,6 +42,7 @@
 #include <AVSCommon/Utils/Timing/Timer.h>
 #include <AVSCommon/Utils/Timing/TimeUtils.h>
 #include <Captions/CaptionManagerInterface.h>
+#include <CertifiedSender/CertifiedSender.h>
 
 #include "AudioItem.h"
 #include "ClearBehavior.h"
@@ -90,6 +91,7 @@ public:
         std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
         std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
         std::shared_ptr<avsCommon::sdkInterfaces::PlaybackRouterInterface> playbackRouter,
+        std::shared_ptr<certifiedSender::CertifiedSender> certifiedMessageSender,
         std::shared_ptr<captions::CaptionManagerInterface> captionManager = nullptr);
 
     /// @name StateProviderInterface Functions
@@ -229,6 +231,7 @@ private:
         std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
         std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
         std::shared_ptr<avsCommon::sdkInterfaces::PlaybackRouterInterface> playbackRouter,
+        std::shared_ptr<certifiedSender::CertifiedSender> certifiedMessageSender,
         std::shared_ptr<captions::CaptionManagerInterface> captionManager = nullptr);
 
     /// @name RequiresShutdown Functions
@@ -660,6 +663,10 @@ private:
      *     before the Executor Thread Variables are destroyed.
      */
     avsCommon::utils::threading::Executor m_executor;
+
+    /// The CertifiedSender object.
+    std::shared_ptr<certifiedSender::CertifiedSender> m_certifiedSender;
+
 };
 
 }  // namespace audioPlayer
diff --git a/CapabilityAgents/AudioPlayer/src/AudioPlayer.cpp b/CapabilityAgents/AudioPlayer/src/AudioPlayer.cpp
index 340abe32..191a1a50 100644
--- a/CapabilityAgents/AudioPlayer/src/AudioPlayer.cpp
+++ b/CapabilityAgents/AudioPlayer/src/AudioPlayer.cpp
@@ -38,6 +38,7 @@ using namespace avsCommon::utils;
 using namespace avsCommon::utils::json;
 using namespace avsCommon::utils::logger;
 using namespace avsCommon::utils::mediaPlayer;
+using namespace certifiedSender;
 
 /// AudioPlayer capability constants
 /// AudioPlayer interface type
@@ -151,6 +152,7 @@ std::shared_ptr<AudioPlayer> AudioPlayer::create(
     std::shared_ptr<ContextManagerInterface> contextManager,
     std::shared_ptr<ExceptionEncounteredSenderInterface> exceptionSender,
     std::shared_ptr<PlaybackRouterInterface> playbackRouter,
+    std::shared_ptr<certifiedSender::CertifiedSender> certifiedMessageSender,
     std::shared_ptr<captions::CaptionManagerInterface> captionManager) {
     if (nullptr == mediaPlayerFactory) {
         ACSDK_ERROR(LX("createFailed").d("reason", "nullMediaPlayerFactory"));
@@ -170,8 +172,12 @@ std::shared_ptr<AudioPlayer> AudioPlayer::create(
     } else if (nullptr == playbackRouter) {
         ACSDK_ERROR(LX("createFailed").d("reason", "nullPlaybackRouter"));
         return nullptr;
+    } else if (nullptr == certifiedMessageSender) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullCertifiedMessageSender"));
+        return nullptr;
     }
 
+
     auto audioPlayer = std::shared_ptr<AudioPlayer>(new AudioPlayer(
         std::move(mediaPlayerFactory),
         messageSender,
@@ -179,6 +185,7 @@ std::shared_ptr<AudioPlayer> AudioPlayer::create(
         contextManager,
         exceptionSender,
         playbackRouter,
+        certifiedMessageSender,
         captionManager));
     contextManager->setStateProvider(STATE, audioPlayer);
     audioPlayer->m_mediaPlayerFactory->addObserver(audioPlayer);
@@ -477,6 +484,7 @@ AudioPlayer::AudioPlayer(
     std::shared_ptr<ContextManagerInterface> contextManager,
     std::shared_ptr<ExceptionEncounteredSenderInterface> exceptionSender,
     std::shared_ptr<PlaybackRouterInterface> playbackRouter,
+    std::shared_ptr<certifiedSender::CertifiedSender> certifiedMessageSender,
     std::shared_ptr<captions::CaptionManagerInterface> captionManager) :
         CapabilityAgent{NAMESPACE, exceptionSender},
         RequiresShutdown{"AudioPlayer"},
@@ -491,7 +499,8 @@ AudioPlayer::AudioPlayer(
         m_currentlyPlaying(std::make_shared<PlayDirectiveInfo>("")),
         m_offset{std::chrono::milliseconds{std::chrono::milliseconds::zero()}},
         m_isStopCalled{false},
-        m_okToRequestNextTrack{false} {
+        m_okToRequestNextTrack{false},
+        m_certifiedSender{certifiedMessageSender} {
     m_capabilityConfigurations.insert(getAudioPlayerCapabilityConfiguration());
 }
 
@@ -518,6 +527,7 @@ void AudioPlayer::doShutdown() {
     m_audioPlayQueue.clear();
     m_playbackRouter.reset();
     m_captionManager.reset();
+    m_certifiedSender.reset();
 }
 
 bool AudioPlayer::parseDirectivePayload(std::shared_ptr<DirectiveInfo> info, rapidjson::Document* document) {
@@ -1420,14 +1430,14 @@ void AudioPlayer::executePrePlay(std::shared_ptr<PlayDirectiveInfo> info) {
 void AudioPlayer::executePlay(const std::string& messageId) {
     ACSDK_DEBUG1(LX(__func__));
 
-    auto playItem = m_audioPlayQueue.front();
-
     if (m_audioPlayQueue.empty()) {
         ACSDK_ERROR(
-            LX("executePlayFailed").d("reason", "unhandledPlayBehavior").d("playBehavior", playItem->playBehavior));
+            LX("executePlayFailed").d("reason", "emptyPlayQueue").d("messageId", messageId));
         return;
     }
 
+    auto playItem = m_audioPlayQueue.front();
+
     if (playItem->playBehavior != PlayBehavior::ENQUEUE && playItem->messageId != messageId) {
         ACSDK_ERROR(LX("executePlayFailed").d("reason", "TrackNotHeadOfQueue"));
         return;
@@ -1607,6 +1617,10 @@ void AudioPlayer::sendEventWithTokenAndOffset(const std::string& eventName, std:
     }
 
     auto event = buildJsonEventString(eventName, "", buffer.GetString());
+    if (eventName == "PlaybackNearlyFinished" || eventName == "PlaybackFinished" ) {
+        m_certifiedSender->sendJSONMessage(event.second);
+        return;
+    }
     auto request = std::make_shared<MessageRequest>(event.second);
     m_messageSender->sendMessage(request);
 }
diff --git a/CapabilityAgents/AudioPlayer/src/CMakeLists.txt b/CapabilityAgents/AudioPlayer/src/CMakeLists.txt
index 1d650e62..23362e80 100644
--- a/CapabilityAgents/AudioPlayer/src/CMakeLists.txt
+++ b/CapabilityAgents/AudioPlayer/src/CMakeLists.txt
@@ -4,10 +4,15 @@ add_library(AudioPlayer SHARED
     ProgressTimer.cpp)
 target_include_directories(AudioPlayer PUBLIC
     "${AudioPlayer_SOURCE_DIR}/include"
+    "${CertifiedSender_SOURCE_DIR}/include"
+    "${SQLiteStorage_SOURCE_DIR}/include"
     "${AVSCommon_INCLUDE_DIRS}")
 target_link_libraries(AudioPlayer
     Captions
-    AVSCommon)
+    AVSCommon
+    CertifiedSender 
+    SQLiteStorage)
+
 
 # install target
 asdk_install()
diff --git a/CapabilityAgents/AudioPlayer/test/AudioPlayerTest.cpp b/CapabilityAgents/AudioPlayer/test/AudioPlayerTest.cpp
index 4a2d1f4b..1ffe9205 100644
--- a/CapabilityAgents/AudioPlayer/test/AudioPlayerTest.cpp
+++ b/CapabilityAgents/AudioPlayer/test/AudioPlayerTest.cpp
@@ -37,6 +37,7 @@
 #include <AVSCommon/SDKInterfaces/MockFocusManager.h>
 #include <AVSCommon/SDKInterfaces/MockMessageSender.h>
 #include <AVSCommon/SDKInterfaces/MockPlaybackRouter.h>
+#include <AVSCommon/SDKInterfaces/MockAVSConnectionManager.h>
 #include <AVSCommon/Utils/JSON/JSONUtils.h>
 #include <AVSCommon/Utils/Logger/ConsoleLogger.h>
 #include <AVSCommon/Utils/MediaPlayer/MockMediaPlayer.h>
@@ -65,6 +66,8 @@ using namespace captions::test;
 using namespace avsCommon::utils::mediaPlayer::test;
 using namespace ::testing;
 using namespace rapidjson;
+using namespace certifiedSender;
+using namespace registrationManager;
 
 /// Plenty of time for a test to complete.
 static std::chrono::milliseconds WAIT_TIMEOUT(1000);
@@ -394,6 +397,43 @@ static const std::string STREAM_METADATA_EXTRACTED_NAME = "StreamMetadataExtract
 /// String to identify log entries originating from this file.
 static const std::string TAG("AudioPlayerTest");
 
+    /**
+     * Test @c MessageStorageInterface implementation to provide a valid instance for the initialization of other
+     * components.
+     */
+    class StubMessageStorage : public MessageStorageInterface {
+    public:
+        bool createDatabase() override {
+            return true;
+        }
+        
+        bool open() override {
+            return true;
+        }
+        
+        void close() override {
+        }
+        
+        bool store(const std::string& message, int* id) override {
+            return true;
+        }
+        
+        bool store(const std::string& message, const std::string& uriPathExtension, int* id) override {
+            return true;
+        }
+        
+        bool load(std::queue<StoredMessage>* messageContainer) override {
+            return true;
+        }
+        
+        bool erase(int messageId) override {
+            return true;
+        }
+        
+        bool clearDatabase() override {
+            return true;
+        }
+    };
 /**
  * Create a LogEntry using this file's TAG and the specified event string.
  *
@@ -490,6 +530,15 @@ public:
     /// Identifier for the currently selected audio source.
     MediaPlayerInterface::SourceId m_sourceId;
 
+    std::shared_ptr<MockAVSConnectionManager> m_mockAVSConnectionManager;
+
+    std::shared_ptr<StubMessageStorage> m_messageStorage;
+
+    std::shared_ptr<CustomerDataManager> m_customerDataManager;
+
+    std::shared_ptr<CertifiedSender> m_certifiedSender;
+
+
     /**
      * This is invoked in response to a @c setState call.
      *
@@ -655,6 +704,12 @@ void AudioPlayerTest::SetUp() {
         m_mockMediaPlayer, m_mockMediaPlayerTrack2, m_mockMediaPlayerTrack3};
     m_mockFactory = alexaClientSDK::mediaPlayer::PooledMediaPlayerFactory::create(pool);
     m_mockCaptionManager = std::make_shared<NiceMock<MockCaptionManager>>();
+    m_mockAVSConnectionManager = std::make_shared<NiceMock<MockAVSConnectionManager>>();
+    m_messageStorage = std::make_shared<StubMessageStorage>();
+
+    m_certifiedSender = CertifiedSender::create(
+        m_mockMessageSender, m_mockAVSConnectionManager, m_messageStorage, m_customerDataManager);
+
     m_audioPlayer = AudioPlayer::create(
         std::move(m_mockFactory),
         m_mockMessageSender,
@@ -662,6 +717,7 @@ void AudioPlayerTest::SetUp() {
         m_mockContextManager,
         m_mockExceptionSender,
         m_mockPlaybackRouter,
+        m_certifiedSender,
         m_mockCaptionManager);
 
     ASSERT_TRUE(m_audioPlayer);
@@ -703,7 +759,8 @@ void AudioPlayerTest::reSetUp(int numberOfPlayers) {
         m_mockFocusManager,
         m_mockContextManager,
         m_mockExceptionSender,
-        m_mockPlaybackRouter);
+        m_mockPlaybackRouter,
+        m_certifiedSender);
 
     ASSERT_TRUE(m_audioPlayer);
 
@@ -908,6 +965,7 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         m_mockContextManager,
         m_mockExceptionSender,
         m_mockPlaybackRouter,
+        m_certifiedSender,
         m_mockCaptionManager);
     EXPECT_EQ(testAudioPlayer, nullptr);
 
@@ -919,6 +977,7 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         m_mockContextManager,
         m_mockExceptionSender,
         m_mockPlaybackRouter,
+        m_certifiedSender,
         m_mockCaptionManager);
     EXPECT_EQ(testAudioPlayer, nullptr);
 
@@ -930,6 +989,7 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         m_mockContextManager,
         m_mockExceptionSender,
         m_mockPlaybackRouter,
+        m_certifiedSender,
         m_mockCaptionManager);
     EXPECT_EQ(testAudioPlayer, nullptr);
 
@@ -941,6 +1001,7 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         nullptr,
         m_mockExceptionSender,
         m_mockPlaybackRouter,
+        m_certifiedSender,
         m_mockCaptionManager);
     EXPECT_EQ(testAudioPlayer, nullptr);
 
@@ -952,6 +1013,19 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         m_mockContextManager,
         nullptr,
         m_mockPlaybackRouter,
+        m_certifiedSender,
+        m_mockCaptionManager);
+    EXPECT_EQ(testAudioPlayer, nullptr);
+
+    m_mockFactory = alexaClientSDK::mediaPlayer::PooledMediaPlayerFactory::create(pool);
+    testAudioPlayer = AudioPlayer::create(
+        std::move(m_mockFactory),
+        m_mockMessageSender,
+        m_mockFocusManager,
+        m_mockContextManager,
+        m_mockExceptionSender,
+        nullptr,
+        m_certifiedSender,
         m_mockCaptionManager);
     EXPECT_EQ(testAudioPlayer, nullptr);
 
@@ -962,6 +1036,7 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         m_mockFocusManager,
         m_mockContextManager,
         m_mockExceptionSender,
+        m_mockPlaybackRouter,
         nullptr,
         m_mockCaptionManager);
     EXPECT_EQ(testAudioPlayer, nullptr);
diff --git a/CapabilityAgents/DoNotDisturb/include/DoNotDisturbCA/DoNotDisturbCapabilityAgent.h b/CapabilityAgents/DoNotDisturb/include/DoNotDisturbCA/DoNotDisturbCapabilityAgent.h
index ba38ff31..0a80190a 100644
--- a/CapabilityAgents/DoNotDisturb/include/DoNotDisturbCA/DoNotDisturbCapabilityAgent.h
+++ b/CapabilityAgents/DoNotDisturb/include/DoNotDisturbCA/DoNotDisturbCapabilityAgent.h
@@ -50,11 +50,11 @@ namespace doNotDisturb {
  */
 class DoNotDisturbCapabilityAgent
         : public std::enable_shared_from_this<DoNotDisturbCapabilityAgent>
-        , public avsCommon::avs::CapabilityAgent
-        , public avsCommon::sdkInterfaces::CapabilityConfigurationInterface
-        , public avsCommon::sdkInterfaces::ConnectionStatusObserverInterface
-        , public avsCommon::utils::RequiresShutdown
-        , public settings::SettingEventSenderInterface {
+        , public alexaClientSDK::avsCommon::avs::CapabilityAgent
+        , public alexaClientSDK::avsCommon::sdkInterfaces::CapabilityConfigurationInterface
+        , public alexaClientSDK::avsCommon::sdkInterfaces::ConnectionStatusObserverInterface
+        , public alexaClientSDK::avsCommon::utils::RequiresShutdown
+        , public alexaClientSDK::settings::SettingEventSenderInterface {
 public:
     /**
      * Destructor.
@@ -70,22 +70,22 @@ public:
      * @return A new instance of @c DoNotDisturbCapabilityAgent on success, @c nullptr otherwise.
      */
     static std::shared_ptr<DoNotDisturbCapabilityAgent> create(
-        std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionEncounteredSender,
-        std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender,
-        std::shared_ptr<settings::storage::DeviceSettingStorageInterface> settingsStorage);
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionEncounteredSender,
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::MessageSenderInterface> messageSender,
+        std::shared_ptr<alexaClientSDK::settings::storage::DeviceSettingStorageInterface> settingsStorage);
 
     /// @name CapabilityAgent Functions
     /// @{
-    avsCommon::avs::DirectiveHandlerConfiguration getConfiguration() const override;
-    void handleDirectiveImmediately(std::shared_ptr<avsCommon::avs::AVSDirective> directive) override;
-    void preHandleDirective(std::shared_ptr<avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
-    void handleDirective(std::shared_ptr<avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
-    void cancelDirective(std::shared_ptr<avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
+    alexaClientSDK::avsCommon::avs::DirectiveHandlerConfiguration getConfiguration() const override;
+    void handleDirectiveImmediately(std::shared_ptr<alexaClientSDK::avsCommon::avs::AVSDirective> directive) override;
+    void preHandleDirective(std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
+    void handleDirective(std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
+    void cancelDirective(std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
     /// @}
 
     /// @name CapabilityConfigurationInterface Functions
     /// @{
-    std::unordered_set<std::shared_ptr<avsCommon::avs::CapabilityConfiguration>> getCapabilityConfigurations() override;
+    std::unordered_set<std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityConfiguration>> getCapabilityConfigurations() override;
     /// @}
 
     // @name RequiresShutdown Functions
@@ -118,7 +118,7 @@ public:
      *
      * @return The do not disturb events metadata.
      */
-    static settings::SettingEventMetadata getDoNotDisturbEventsMetadata();
+    static alexaClientSDK::settings::SettingEventMetadata getDoNotDisturbEventsMetadata();
 
 private:
     /**
@@ -128,8 +128,8 @@ private:
      * @param messageSender Interface to send events to AVS.
      */
     DoNotDisturbCapabilityAgent(
-        std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionEncounteredSender,
-        std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender);
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionEncounteredSender,
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::MessageSenderInterface> messageSender);
 
     /**
      * Method to initialize the new instance of the capability agent.
@@ -137,7 +137,7 @@ private:
      * @param settingsStorage The storage interface that will be used to store device settings.
      * @return True on success, false otherwise.
      */
-    bool initialize(std::shared_ptr<settings::storage::DeviceSettingStorageInterface> settingsStorage);
+    bool initialize(std::shared_ptr<alexaClientSDK::settings::storage::DeviceSettingStorageInterface> settingsStorage);
 
     /**
      * Sends a DND event to the AVS.
@@ -146,7 +146,7 @@ private:
      * @param value Valid JSON string representation of the boolean value. I.e. either "true" or "false".
      * @return Future to track the completion status of the message.
      */
-    std::shared_future<avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status> sendDNDEvent(
+    std::shared_future<alexaClientSDK::avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status> sendDNDEvent(
         const std::string& eventName,
         const std::string& value);
 
@@ -164,17 +164,17 @@ private:
      * implies that exception has been reported to AVS and directive is already processed.
      */
     bool handleSetDoNotDisturbDirective(
-        std::shared_ptr<avsCommon::avs::CapabilityAgent::DirectiveInfo> info,
+        std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityAgent::DirectiveInfo> info,
         rapidjson::Document& document);
 
     /// Set of capability configurations that will get published using DCF
-    std::unordered_set<std::shared_ptr<avsCommon::avs::CapabilityConfiguration>> m_capabilityConfigurations;
+    std::unordered_set<std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityConfiguration>> m_capabilityConfigurations;
 
     /// The @c MessageSenderInterface used to send event messages.
-    std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> m_messageSender;
+    std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::MessageSenderInterface> m_messageSender;
 
     /// The do not disturb mode setting.
-    std::shared_ptr<settings::Setting<bool>> m_dndModeSetting;
+    std::shared_ptr<alexaClientSDK::settings::Setting<bool>> m_dndModeSetting;
 
     /**
      * Flag indicating latest reported connection status. True if SDK is connected to the AVS and ready,
diff --git a/CapabilityAgents/ExternalMediaPlayer/include/ExternalMediaPlayer/ExternalMediaPlayer.h b/CapabilityAgents/ExternalMediaPlayer/include/ExternalMediaPlayer/ExternalMediaPlayer.h
index b859abb3..1dfc8000 100644
--- a/CapabilityAgents/ExternalMediaPlayer/include/ExternalMediaPlayer/ExternalMediaPlayer.h
+++ b/CapabilityAgents/ExternalMediaPlayer/include/ExternalMediaPlayer/ExternalMediaPlayer.h
@@ -21,6 +21,11 @@
 #include <mutex>
 #include <string>
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+#include <AVSCommon/AVS/CapabilityConfiguration.h>
+#include <AVSCommon/AVS/PlayerActivity.h>
+#include <AVSCommon/SDKInterfaces/ExternalMediaAdapterHandlerInterface.h>
+#endif
 #include <AVSCommon/AVS/CapabilityAgent.h>
 #include <AVSCommon/AVS/DirectiveHandlerConfiguration.h>
 #include <AVSCommon/SDKInterfaces/CapabilityConfigurationInterface.h>
@@ -43,6 +48,23 @@ namespace alexaClientSDK {
 namespace capabilityAgents {
 namespace externalMediaPlayer {
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+/// Enum to identify the initiator type of a stop.
+enum class HaltInitiator {
+    /// The system is not halted.
+    NONE,
+
+    /// Voice initiated Pause request from AVS/Pause from Spotify Connect.
+    EXTERNAL_PAUSE,
+
+    /// Pause was initiated when focus changed from FOREGROUND to BACKGROUND.
+    FOCUS_CHANGE_PAUSE,
+
+    /// Stop initiated when focus changed from FOREGROUND/BACKGROUND to NONE.
+    FOCUS_CHANGE_STOP
+};
+#endif
+
 /**
  * This class implements the @c ExternalMediaPlayer capability agent. This agent is responsible for handling
  * music service providers which manage their PLAY queue.
@@ -108,6 +130,21 @@ public:
         std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
         std::shared_ptr<avsCommon::sdkInterfaces::PlaybackRouterInterface> playbackRouter);
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    void addAdapterHandler(std::shared_ptr<avsCommon::sdkInterfaces::ExternalMediaAdapterHandlerInterface> adapterHandler);
+    void removeAdapterHandler(std::shared_ptr<avsCommon::sdkInterfaces::ExternalMediaAdapterHandlerInterface> adapterHandler);
+#endif
+
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    void executeOnFocusChanged(avsCommon::avs::FocusState newFocus);
+
+    void onFocusChanged(avsCommon::avs::FocusState newFocus) override;
+
+    void onContextAvailable(const std::string& jsonContext) override;
+
+    void onContextFailure(const avsCommon::sdkInterfaces::ContextRequestError error) override;
+#endif
+
     /// @name StateProviderInterface Functions
     /// @{
     void provideState(const avsCommon::avs::NamespaceAndName& stateProviderName, unsigned int stateRequestToken)
@@ -133,6 +170,12 @@ public:
 
     /// @name Overridden ExternalMediaPlayerInterface methods.
     /// @{
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    virtual void setCurrentActivity(const avsCommon::avs::PlayerActivity currentActivity) override;
+
+    virtual void setPlayerInFocus(const std::string& playerInFocus, bool focusAcquire) override;
+#endif
+
     virtual void setPlayerInFocus(const std::string& playerInFocus) override;
     /// @}
 
@@ -189,12 +232,20 @@ private:
     /**
      * This method returns the ExternalMediaPlayer session state registered in the ExternalMediaPlayer namespace.
      */
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    std::string provideSessionState(std::vector<avsCommon::sdkInterfaces::externalMediaPlayer::AdapterState> adapterStates);
+#else
     std::string provideSessionState();
+#endif
 
     /**
      * This method returns the Playback state registered in the Alexa.PlaybackStateReporter state.
      */
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    std::string providePlaybackState(std::vector<avsCommon::sdkInterfaces::externalMediaPlayer::AdapterState> adapterStates);
+#else
     std::string providePlaybackState();
+#endif
 
     /**
      * This function deserializes a @c Directive's payload into a @c rapidjson::Document.
@@ -237,6 +288,15 @@ private:
         std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerInterface> focusManager,
         std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager);
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    /**
+     * Set the appropriate halt initiator for the request.
+     *
+     * @param The type of the request.
+     */
+    void setHaltInitiatorRequestHelper(avsCommon::sdkInterfaces::externalMediaPlayer::RequestType request);
+#endif
+
     /**
      * Send the handling completed notification and clean up the resources the specified @c DirectiveInfo.
      *
@@ -293,6 +353,19 @@ private:
         std::shared_ptr<DirectiveInfo> info,
         rapidjson::Document* document);
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    /**
+     * Handler for AuthorizeDiscoveredPlayers directive.
+     *
+     * @param info The DirectiveInfo to be processed.
+     * @param The type of the request. Will be NONE for the
+     *        handleAuthorizeDiscoveredPlayers case.
+     */
+    void handleAuthorizeDiscoveredPlayers(
+        std::shared_ptr<DirectiveInfo> info,
+        avsCommon::sdkInterfaces::externalMediaPlayer::RequestType request);
+#endif
+
     /**
      * Handler for login directive.
      *
@@ -429,6 +502,33 @@ private:
     /// Observer for changes related to RenderPlayerInfoCards.
     std::shared_ptr<avsCommon::sdkInterfaces::RenderPlayerInfoCardsObserverInterface> m_renderPlayerObserver;
 
+    #ifdef EXTERNALMEDIAPLAYER_1_1
+        std::unordered_set<std::shared_ptr<avsCommon::sdkInterfaces::ExternalMediaAdapterHandlerInterface>> m_adapterHandlers;
+    #endif
+
+    #ifdef EXTERNALMEDIAPLAYER_1_1
+        /// The @c FocusManager used to manage usage of the channel.
+        std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerInterface> m_focusManager;
+
+        /// The current focus state of the @c AudioPlayer on the content channel.
+        avsCommon::avs::FocusState m_focus;
+
+        /// bool to identify if acquire of focus is currently in progress.
+        bool m_focusAcquireInProgress;
+
+        /// Enum to identify the type and source of the halt request.
+        HaltInitiator m_haltInitiator;
+
+        /// The current state of the @c ExternalMediaPlayer.
+        avsCommon::avs::PlayerActivity m_currentActivity;
+
+        /// Protects writes to @c m_currentActivity and waiting on @c m_currentActivityConditionVariable.
+        std::mutex m_currentActivityMutex;
+
+        /// Provides notifications of changes to @c m_currentActivity.
+        std::condition_variable m_currentActivityConditionVariable;
+    #endif
+
     /**
      * @c Executor which queues up operations from asynchronous API calls.
      *
diff --git a/CapabilityAgents/ExternalMediaPlayer/src/ExternalMediaPlayer.cpp b/CapabilityAgents/ExternalMediaPlayer/src/ExternalMediaPlayer.cpp
index cf77ebc2..6c19f45a 100644
--- a/CapabilityAgents/ExternalMediaPlayer/src/ExternalMediaPlayer.cpp
+++ b/CapabilityAgents/ExternalMediaPlayer/src/ExternalMediaPlayer.cpp
@@ -14,9 +14,6 @@
  */
 
 /// @file ExternalMediaPlayer.cpp
-#include <utility>
-#include <vector>
-
 #include "ExternalMediaPlayer/ExternalMediaPlayer.h"
 
 #include <rapidjson/stringbuffer.h>
@@ -78,8 +75,13 @@ static const std::string EXTERNALMEDIAPLAYER_CAPABILITY_INTERFACE_TYPE = ALEXA_I
 /// ExternalMediaPlayer interface name
 static const std::string EXTERNALMEDIAPLAYER_CAPABILITY_INTERFACE_NAME = "ExternalMediaPlayer";
 /// ExternalMediaPlayer interface version
+#ifdef EXTERNALMEDIAPLAYER_1_1
+static const std::string EXTERNALMEDIAPLAYER_CAPABILITY_INTERFACE_VERSION = "1.1";
+#else
 static const std::string EXTERNALMEDIAPLAYER_CAPABILITY_INTERFACE_VERSION = "1.0";
+#endif
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
 /// Alexa.PlaybackStateReporter name.
 static const std::string PLAYBACKSTATEREPORTER_CAPABILITY_INTERFACE_NAME = PLAYBACKSTATEREPORTER_STATE_NAMESPACE;
 /// Alexa.PlaybackStateReporter version.
@@ -104,11 +106,30 @@ static const std::string SEEKCONTROLLER_CAPABILITY_INTERFACE_VERSION = "1.0";
 static const std::string FAVORITESCONTROLLER_CAPABILITY_INTERFACE_NAME = FAVORITESCONTROLLER_NAMESPACE;
 /// Alexa.FavoritesController version.
 static const std::string FAVORITESCONTROLLER_CAPABILITY_INTERFACE_VERSION = "1.0";
+#endif
+
+#ifdef EXTERNALMEDIAPLAYER_1_1
+/// The name of the @c FocusManager channel used by @c ExternalMediaPlayer and
+/// its Adapters.
+static const std::string CHANNEL_NAME = avsCommon::sdkInterfaces::FocusManagerInterface::CONTENT_CHANNEL_NAME;
+
+/**
+ * The activityId string used with @c FocusManager by @c ExternalMediaPlayer.
+ * (as per spec for AVS for monitoring channel activity.)
+ */
+static const std::string FOCUS_MANAGER_ACTIVITY_ID = "ExternalMediaPlayer";
+
+/// The duration to wait for a state change in @c onFocusChanged before failing.
+static const std::chrono::seconds TIMEOUT{2};
+#endif
 
 // The @c External media player play directive signature.
 static const NamespaceAndName PLAY_DIRECTIVE{EXTERNALMEDIAPLAYER_NAMESPACE, "Play"};
 static const NamespaceAndName LOGIN_DIRECTIVE{EXTERNALMEDIAPLAYER_NAMESPACE, "Login"};
 static const NamespaceAndName LOGOUT_DIRECTIVE{EXTERNALMEDIAPLAYER_NAMESPACE, "Logout"};
+#ifdef EXTERNALMEDIAPLAYER_1_1
+static const NamespaceAndName AUTHORIZEDISCOVEREDPLAYERS_DIRECTIVE{EXTERNALMEDIAPLAYER_NAMESPACE, "AuthorizeDiscoveredPlayers"};
+#endif
 
 // The @c Transport control directive signatures.
 static const NamespaceAndName RESUME_DIRECTIVE{PLAYBACKCONTROLLER_NAMESPACE, "Play"};
@@ -161,6 +182,9 @@ static std::shared_ptr<avsCommon::avs::CapabilityConfiguration> getExternalMedia
 /// The @c m_directiveToHandlerMap Map of the directives to their handlers.
 std::unordered_map<NamespaceAndName, std::pair<RequestType, ExternalMediaPlayer::DirectiveHandler>>
     ExternalMediaPlayer::m_directiveToHandlerMap = {
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        {AUTHORIZEDISCOVEREDPLAYERS_DIRECTIVE, std::make_pair(RequestType::NONE, &ExternalMediaPlayer::handleAuthorizeDiscoveredPlayers)},
+#endif
         {LOGIN_DIRECTIVE, std::make_pair(RequestType::LOGIN, &ExternalMediaPlayer::handleLogin)},
         {LOGOUT_DIRECTIVE, std::make_pair(RequestType::LOGOUT, &ExternalMediaPlayer::handleLogout)},
         {PLAY_DIRECTIVE, std::make_pair(RequestType::PLAY, &ExternalMediaPlayer::handlePlay)},
@@ -187,7 +211,12 @@ std::unordered_map<NamespaceAndName, std::pair<RequestType, ExternalMediaPlayer:
 auto audioNonBlockingPolicy = BlockingPolicy(BlockingPolicy::MEDIUM_AUDIO, false);
 auto neitherNonBlockingPolicy = BlockingPolicy(BlockingPolicy::MEDIUMS_NONE, false);
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+static DirectiveHandlerConfiguration g_configuration = {{AUTHORIZEDISCOVEREDPLAYERS_DIRECTIVE, audioNonBlockingPolicy},
+                                                        {PLAY_DIRECTIVE, audioNonBlockingPolicy},
+#else
 static DirectiveHandlerConfiguration g_configuration = {{PLAY_DIRECTIVE, audioNonBlockingPolicy},
+#endif
                                                         {LOGIN_DIRECTIVE, neitherNonBlockingPolicy},
                                                         {LOGOUT_DIRECTIVE, neitherNonBlockingPolicy},
                                                         {RESUME_DIRECTIVE, audioNonBlockingPolicy},
@@ -209,15 +238,21 @@ static DirectiveHandlerConfiguration g_configuration = {{PLAY_DIRECTIVE, audioNo
                                                         {UNFAVORITE_DIRECTIVE, neitherNonBlockingPolicy}};
 
 static std::unordered_map<PlaybackButton, RequestType> g_buttonToRequestType = {
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    // Important Note: This changes default AVS Device SDK behavior.
+    {PlaybackButton::PLAY, RequestType::RESUME},
+    {PlaybackButton::PAUSE, RequestType::PAUSE},
+#else
     {PlaybackButton::PLAY, RequestType::PAUSE_RESUME_TOGGLE},
     {PlaybackButton::PAUSE, RequestType::PAUSE_RESUME_TOGGLE},
+#endif
     {PlaybackButton::NEXT, RequestType::NEXT},
     {PlaybackButton::PREVIOUS, RequestType::PREVIOUS}};
 
 static std::unordered_map<PlaybackToggle, std::pair<RequestType, RequestType>> g_toggleToRequestType = {
     {PlaybackToggle::SHUFFLE, std::make_pair(RequestType::ENABLE_SHUFFLE, RequestType::DISABLE_SHUFFLE)},
     {PlaybackToggle::LOOP, std::make_pair(RequestType::ENABLE_REPEAT, RequestType::DISABLE_REPEAT)},
-    {PlaybackToggle::REPEAT, std::make_pair(RequestType::ENABLE_REPEAT_ONE, RequestType::DISABLE_REPEAT_ONE)},
+    {PlaybackToggle::REPEAT, std::make_pair(RequestType::ENABLE_REPEAT_ONE, RequestType::DISABLE_REPEAT)},
     {PlaybackToggle::THUMBS_UP, std::make_pair(RequestType::FAVORITE, RequestType::DESELECT_FAVORITE)},
     {PlaybackToggle::THUMBS_DOWN, std::make_pair(RequestType::UNFAVORITE, RequestType::DESELECT_UNFAVORITE)}};
 
@@ -285,6 +320,10 @@ std::shared_ptr<ExternalMediaPlayer> ExternalMediaPlayer::create(
     externalMediaPlayer->createAdapters(
         mediaPlayers, speakers, adapterCreationMap, messageSender, focusManager, contextManager);
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    externalMediaPlayer->m_focusManager = focusManager;
+#endif
+
     return externalMediaPlayer;
 }
 
@@ -297,10 +336,18 @@ ExternalMediaPlayer::ExternalMediaPlayer(
         RequiresShutdown{"ExternalMediaPlayer"},
         m_speakerManager{speakerManager},
         m_contextManager{contextManager},
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        m_playbackRouter{playbackRouter},
+        m_focus{FocusState::NONE},
+        m_focusAcquireInProgress{false},
+        m_haltInitiator{HaltInitiator::NONE},
+        m_currentActivity{avsCommon::avs::PlayerActivity::IDLE} {
+#else
         m_playbackRouter{playbackRouter} {
-    // Register all supported capabilities.
+#endif
     m_capabilityConfigurations.insert(getExternalMediaPlayerCapabilityConfiguration());
-
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    // Register all supported capabilities.
     m_capabilityConfigurations.insert(generateCapabilityConfiguration(
         ALEXA_INTERFACE_TYPE,
         PLAYBACKSTATEREPORTER_CAPABILITY_INTERFACE_NAME,
@@ -323,6 +370,7 @@ ExternalMediaPlayer::ExternalMediaPlayer(
         ALEXA_INTERFACE_TYPE,
         FAVORITESCONTROLLER_CAPABILITY_INTERFACE_NAME,
         FAVORITESCONTROLLER_CAPABILITY_INTERFACE_VERSION));
+#endif
 }
 
 std::shared_ptr<CapabilityConfiguration> getExternalMediaPlayerCapabilityConfiguration() {
@@ -332,6 +380,242 @@ std::shared_ptr<CapabilityConfiguration> getExternalMediaPlayerCapabilityConfigu
         EXTERNALMEDIAPLAYER_CAPABILITY_INTERFACE_VERSION);
 }
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+void ExternalMediaPlayer::addAdapterHandler(
+    std::shared_ptr<avsCommon::sdkInterfaces::ExternalMediaAdapterHandlerInterface> adapterHandler) {
+    ACSDK_DEBUG5(LX("addAdapterHandler"));
+    if (!adapterHandler) {
+        ACSDK_ERROR(LX("addAdapterHandler").m("Adapter handler is null."));
+        return;
+    }
+    m_executor.submit([this, adapterHandler]() {
+        ACSDK_DEBUG5(LX("addAdapterHandlerInExecutor"));
+        if (!m_adapterHandlers.insert(adapterHandler).second) {
+            ACSDK_ERROR(LX("addAdapterHandlerInExecutor").m("Duplicate adapter handler."));
+        }
+    });
+}
+
+void ExternalMediaPlayer::removeAdapterHandler(
+    std::shared_ptr<avsCommon::sdkInterfaces::ExternalMediaAdapterHandlerInterface> adapterHandler) {
+    ACSDK_DEBUG5(LX("removeAdapterHandler"));
+    if (!adapterHandler) {
+        ACSDK_ERROR(LX("removeAdapterHandler").m("Adapter handler is null."));
+        return;
+    }
+    m_executor.submit([this, adapterHandler]() {
+        ACSDK_DEBUG5(LX("removeAdapterHandlerInExecutor"));
+        if (m_adapterHandlers.erase(adapterHandler) == 0) {
+            ACSDK_WARN(LX("removeAdapterHandlerInExecutor").m("Nonexistent adapter handler."));
+        }
+    });
+}
+#endif
+
+#ifdef EXTERNALMEDIAPLAYER_1_1
+void ExternalMediaPlayer::executeOnFocusChanged(avsCommon::avs::FocusState newFocus) {
+    ACSDK_DEBUG1(
+        LX("executeOnFocusChanged").d("from", m_focus).d("to", newFocus).d("m_currentActivity", m_currentActivity));
+    if (m_focus == newFocus) {
+        m_focusAcquireInProgress = false;
+        return;
+    }
+    m_focus = newFocus;
+    m_focusAcquireInProgress = false;
+    {
+		std::lock_guard<std::mutex> lock{m_inFocusAdapterMutex};
+
+        if (!m_playerInFocus.empty()) {
+            switch (newFocus) {
+                case FocusState::FOREGROUND: {
+                    /*
+                        * If the system is currently in a pause initiated from AVS, on focus change
+                        * to FOREGROUND do not try to resume. This happens when a user calls
+                        * "Alexa, pause" while Spotify is PLAYING. This moves the adapter to
+                        * BACKGROUND focus. AVS then sends a PAUSE request and after calling the
+                        * ESDK pause when the adapter switches to FOREGROUND focus we do not want
+                        * the adapter to start PLAYING.
+                        */
+                    if (m_haltInitiator == HaltInitiator::EXTERNAL_PAUSE) {
+                        return;
+                    }
+
+                    switch (m_currentActivity) {
+                        case PlayerActivity::IDLE:
+                        case PlayerActivity::STOPPED:
+                        case PlayerActivity::FINISHED:
+                            return;
+                        case PlayerActivity::PAUSED: {
+                            // At this point a request to play another artist on Spotify may have already
+                            // been processed (or is being processed) and we do not want to send resume here.
+                            if (m_haltInitiator == HaltInitiator::FOCUS_CHANGE_PAUSE) {
+                                for (auto adapterHandler : m_adapterHandlers) {
+                                    adapterHandler->playControlForPlayer(m_playerInFocus, RequestType::RESUME);
+                                    // A focus change to foreground when paused means we should resume the current song.
+                                    ACSDK_DEBUG1(LX("executeOnFocusChanged").d("action", "resumeExternalMediaPlayer"));
+                                    setCurrentActivity(avsCommon::avs::PlayerActivity::PLAYING);
+                                }
+                            }
+                        }
+                            return;
+                        case PlayerActivity::PLAYING:
+                        case PlayerActivity::BUFFER_UNDERRUN:
+                            // We should already have foreground focus in these states; break out to the warning below.
+                            break;
+                    }
+                    break;
+                }
+                case FocusState::BACKGROUND:
+                    switch (m_currentActivity) {
+                        case PlayerActivity::STOPPED:
+                        // We can also end up here with an empty queue if we've asked MediaPlayer to play, but playback
+                        // hasn't started yet, so we fall through to call @c pause() here as well.
+                        case PlayerActivity::FINISHED:
+                        case PlayerActivity::IDLE:
+                        // Note: can be in FINISHED or IDLE while waiting for MediaPlayer to start playing, so we fall
+                        // through to call @c pause() here as well.
+                        case PlayerActivity::PAUSED:
+                        // Note: can be in PAUSED while we're trying to resume, in which case we still want to pause, so we
+                        // fall through to call @c pause() here as well.
+                        case PlayerActivity::PLAYING:
+                        case PlayerActivity::BUFFER_UNDERRUN: {
+                            for (auto adapterHandler : m_adapterHandlers) {
+                                // check against currently known playback state, not already paused
+                                auto adapterStates = adapterHandler->getAdapterStates();
+                                for (auto adapterState : adapterStates) {
+                                    if ( adapterState.sessionState.playerId.compare(m_playerInFocus) == 0 ) { // match playerId
+                                        std::string playbackStateString = adapterState.playbackState.state;
+                                        if ( playbackStateString.compare(playerActivityToString(PlayerActivity::IDLE)) != 0 && 
+                                            playbackStateString.compare(playerActivityToString(PlayerActivity::PAUSED)) != 0 &&
+                                            playbackStateString.compare(playerActivityToString(PlayerActivity::STOPPED)) != 0 ) {
+                                            // only send pause if currently playing
+                                            adapterHandler->playControlForPlayer(m_playerInFocus, RequestType::PAUSE);
+                                            // If we get pushed into the background while playing or buffering, pause the current song.
+                                            ACSDK_DEBUG1(LX("executeOnFocusChanged").d("action", "pauseExternalMediaPlayer"));
+                                            m_haltInitiator = HaltInitiator::FOCUS_CHANGE_PAUSE;
+                                        } else m_haltInitiator = HaltInitiator::EXTERNAL_PAUSE; // Player was not playing, assume external pause
+                                    }
+                                }
+                            }
+                            //update activity state
+                            setCurrentActivity(avsCommon::avs::PlayerActivity::PAUSED);
+                        }
+                            return;
+                    }
+                    break;
+                case FocusState::NONE:
+                    switch (m_currentActivity) {
+                        case PlayerActivity::IDLE:
+                        case PlayerActivity::STOPPED:
+                        case PlayerActivity::FINISHED:
+                            // Nothing to more to do if we're already not playing; we got here because the act of stopping
+                            // caused the channel to be released, which in turn caused this callback.
+                            return;
+                        case PlayerActivity::PLAYING:
+                        case PlayerActivity::PAUSED:
+                        case PlayerActivity::BUFFER_UNDERRUN:
+                            // If the focus change came in while we were in a 'playing' state, we need to stop because we are
+                            // yielding the channel.
+                            ACSDK_DEBUG1(LX("executeOnFocusChanged").d("action", "stopExternalMediaPlayer"));
+                            m_haltInitiator = HaltInitiator::FOCUS_CHANGE_STOP;
+                            setCurrentActivity(avsCommon::avs::PlayerActivity::STOPPED);
+                            for (auto adapterHandler : m_adapterHandlers) {
+                                adapterHandler->playControlForPlayer(m_playerInFocus, RequestType::STOP);
+                            }
+                            return;
+                    }
+                    break;
+            }
+        }
+    }
+    ACSDK_WARN(LX("unexpectedExecuteOnFocusChanged").d("newFocus", newFocus).d("m_currentActivity", m_currentActivity));
+}
+
+void ExternalMediaPlayer::onFocusChanged(FocusState newFocus) {
+    ACSDK_DEBUG(LX("onFocusChanged").d("newFocus", newFocus));
+    m_executor.submit([this, newFocus] { executeOnFocusChanged(newFocus); });
+
+    switch (newFocus) {
+        case FocusState::FOREGROUND:
+            // Could wait for playback to actually start, but there's no real benefit to waiting, and long delays in
+            // buffering could result in timeouts, so returning immediately for this case.
+            return;
+        case FocusState::BACKGROUND: {
+            //Ideally expecting to see a transition to PAUSED, but in terms of user-observable changes, a move to any
+            //of PAUSED/STOPPED/FINISHED will indicate that it's safe for another channel to move to the foreground.
+            auto predicate = [this] {
+                switch (m_currentActivity) {
+                    case PlayerActivity::IDLE:
+                    case PlayerActivity::PAUSED:
+                    case PlayerActivity::STOPPED:
+                    case PlayerActivity::FINISHED:
+                        return true;
+                    case PlayerActivity::PLAYING:
+                    case PlayerActivity::BUFFER_UNDERRUN:
+                        return false;
+                }
+                ACSDK_ERROR(LX("onFocusChangedFailed")
+                                .d("reason", "unexpectedActivity")
+                                .d("m_currentActivity", m_currentActivity));
+                return false;
+            };
+            std::unique_lock<std::mutex> lock(m_currentActivityMutex);
+            if (!m_currentActivityConditionVariable.wait_for(lock, TIMEOUT, predicate)) {
+                ACSDK_ERROR(
+                    LX("onFocusChangedTimedOut").d("newFocus", newFocus).d("m_currentActivity", m_currentActivity));
+            }
+        }
+            return;
+        case FocusState::NONE: {
+            //Need to wait for STOPPED or FINISHED, indicating that we have completely ended playback.
+            auto predicate = [this] {
+                switch (m_currentActivity) {
+                    case PlayerActivity::IDLE:
+                    case PlayerActivity::STOPPED:
+                    case PlayerActivity::FINISHED:
+                        return true;
+                    case PlayerActivity::PLAYING:
+                    case PlayerActivity::PAUSED:
+                    case PlayerActivity::BUFFER_UNDERRUN:
+                        return false;
+                }
+                ACSDK_ERROR(LX("onFocusChangedFailed")
+                                .d("reason", "unexpectedActivity")
+                                .d("m_currentActivity", m_currentActivity));
+                return false;
+            };
+            std::unique_lock<std::mutex> lock(m_currentActivityMutex);
+            if (!m_currentActivityConditionVariable.wait_for(lock, TIMEOUT, predicate)) {
+                ACSDK_ERROR(LX("onFocusChangedFailed")
+                                .d("reason", "activityChangeTimedOut")
+                                .d("newFocus", newFocus)
+                                .d("m_currentActivity", m_currentActivity));
+            }
+            
+            m_executor.submit([this]() {
+                std::unique_lock<std::mutex> lock(m_currentActivityMutex);
+                if ( m_currentActivity == PlayerActivity::STOPPED ) {
+                    std::lock_guard<std::mutex> lock{m_inFocusAdapterMutex};
+                    m_playerInFocus = "";
+            } 
+            });
+              
+                        
+        }
+            return;
+    }
+    ACSDK_ERROR(LX("onFocusChangedFailed").d("reason", "unexpectedFocusState").d("newFocus", newFocus));
+}
+
+void ExternalMediaPlayer::onContextAvailable(const std::string&) {
+    // default no-op
+}
+
+void ExternalMediaPlayer::onContextFailure(const avsCommon::sdkInterfaces::ContextRequestError) {
+    // default no-op
+}
+#endif
+
 void ExternalMediaPlayer::provideState(
     const avsCommon::avs::NamespaceAndName& stateProviderName,
     unsigned int stateRequestToken) {
@@ -409,6 +693,13 @@ std::shared_ptr<ExternalMediaAdapterInterface> ExternalMediaPlayer::preprocessDi
 
     {
         std::lock_guard<std::mutex> lock{m_adaptersMutex};
+
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    if (m_adapters.empty()) { // use handlers when there are no adapters
+        return nullptr;
+    }
+#endif
+
         auto adapterIt = m_adapters.find(playerId);
         if (adapterIt == m_adapters.end()) {
             ACSDK_ERROR(LX("preprocessDirectiveFailed").d("reason", "noAdapterForPlayerId").d(PLAYER_ID, playerId));
@@ -427,11 +718,36 @@ std::shared_ptr<ExternalMediaAdapterInterface> ExternalMediaPlayer::preprocessDi
     return adapter;
 }
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+void ExternalMediaPlayer::handleAuthorizeDiscoveredPlayers(std::shared_ptr<DirectiveInfo> info, RequestType request) {
+    rapidjson::Document payload;
+
+    if (!parseDirectivePayload(info, &payload)) {
+        return;
+    }
+
+    m_executor.submit([this, info]() {
+        for (auto adapterHandler : m_adapterHandlers) {
+            adapterHandler->authorizeDiscoveredPlayers(info->directive->getPayload());
+        }
+        setHandlingCompleted(info);
+    });
+}
+#endif
+
 void ExternalMediaPlayer::handleLogin(std::shared_ptr<DirectiveInfo> info, RequestType request) {
     rapidjson::Document payload;
 
     auto adapter = preprocessDirective(info, &payload);
     if (!adapter) {
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        m_executor.submit([this, info]() {
+            for (auto adapterHandler : m_adapterHandlers) {
+                adapterHandler->login(info->directive->getPayload());
+            }
+            setHandlingCompleted(info);
+        });
+#endif
         return;
     }
 
@@ -470,6 +786,14 @@ void ExternalMediaPlayer::handleLogout(std::shared_ptr<DirectiveInfo> info, Requ
 
     auto adapter = preprocessDirective(info, &payload);
     if (!adapter) {
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        m_executor.submit([this, info]() {
+            for (auto adapterHandler : m_adapterHandlers) {
+                adapterHandler->logout(info->directive->getPayload());
+            }
+            setHandlingCompleted(info);
+        });
+#endif
         return;
     }
 
@@ -482,6 +806,15 @@ void ExternalMediaPlayer::handlePlay(std::shared_ptr<DirectiveInfo> info, Reques
 
     auto adapter = preprocessDirective(info, &payload);
     if (!adapter) {
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        setHaltInitiatorRequestHelper(request);
+        m_executor.submit([this, info]() {
+            for (auto adapterHandler : m_adapterHandlers) {
+                adapterHandler->play(info->directive->getPayload());
+            }
+            setHandlingCompleted(info);
+        });
+#endif
         return;
     }
 
@@ -502,8 +835,41 @@ void ExternalMediaPlayer::handlePlay(std::shared_ptr<DirectiveInfo> info, Reques
         index = 0;
     }
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    std::string skillToken;
+    if (!jsonUtils::retrieveValue(payload, "skillToken", &skillToken)) {
+        ACSDK_ERROR(LX("handleDirectiveFailed").d("reason", "nullSkillToken"));
+        sendExceptionEncounteredAndReportFailed(info, "missing skillToken in Play directive");
+        return;
+    }
+
+    std::string playbackSessionId;
+    if (!jsonUtils::retrieveValue(payload, "playbackSessionId", &playbackSessionId)) {
+        ACSDK_ERROR(LX("handleDirectiveFailed").d("reason", "nullPlaybackSessionId"));
+        sendExceptionEncounteredAndReportFailed(info, "missing playbackSessionId in Play directive");
+        return;
+    }
+
+    std::string navigation;
+    if (!jsonUtils::retrieveValue(payload, "navigation", &navigation)) {
+        ACSDK_ERROR(LX("handleDirectiveFailed").d("reason", "nullNavigation"));
+        sendExceptionEncounteredAndReportFailed(info, "missing navigation in Play directive");
+        return;
+    }
+
+    bool preload;
+    if (!jsonUtils::retrieveValue(payload, "preload", &preload)) {
+        ACSDK_ERROR(LX("handleDirectiveFailed").d("reason", "nullPreload"));
+        sendExceptionEncounteredAndReportFailed(info, "missing preload in Play directive");
+        return;
+    }
+
+    setHandlingCompleted(info);
+    adapter->handlePlay(playbackContextToken, index, std::chrono::milliseconds(offset), skillToken, playbackSessionId, navigation, preload);
+#else
     setHandlingCompleted(info);
     adapter->handlePlay(playbackContextToken, index, std::chrono::milliseconds(offset));
+#endif
 }
 
 void ExternalMediaPlayer::handleSeek(std::shared_ptr<DirectiveInfo> info, RequestType request) {
@@ -511,6 +877,14 @@ void ExternalMediaPlayer::handleSeek(std::shared_ptr<DirectiveInfo> info, Reques
 
     auto adapter = preprocessDirective(info, &payload);
     if (!adapter) {
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        m_executor.submit([this, info]() {
+            for (auto adapterHandler : m_adapterHandlers) {
+                adapterHandler->seek(info->directive->getPayload());
+            }
+            setHandlingCompleted(info);
+        });
+#endif
         return;
     }
 
@@ -530,6 +904,14 @@ void ExternalMediaPlayer::handleAdjustSeek(std::shared_ptr<DirectiveInfo> info,
 
     auto adapter = preprocessDirective(info, &payload);
     if (!adapter) {
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        m_executor.submit([this, info]() {
+            for (auto adapterHandler : m_adapterHandlers) {
+                adapterHandler->adjustSeek(info->directive->getPayload());
+            }
+            setHandlingCompleted(info);
+        });
+#endif
         return;
     }
 
@@ -557,6 +939,15 @@ void ExternalMediaPlayer::handlePlayControl(std::shared_ptr<DirectiveInfo> info,
 
     auto adapter = preprocessDirective(info, &payload);
     if (!adapter) {
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        setHaltInitiatorRequestHelper(request);
+        m_executor.submit([this, info, request]() {
+            for (auto adapterHandler : m_adapterHandlers) {
+                adapterHandler->playControl(info->directive->getPayload(),request);
+            }
+            setHandlingCompleted(info);
+        });
+#endif
         return;
     }
 
@@ -575,6 +966,40 @@ DirectiveHandlerConfiguration ExternalMediaPlayer::getConfiguration() const {
     return g_configuration;
 }
 
+
+#ifdef EXTERNALMEDIAPLAYER_1_1
+
+void ExternalMediaPlayer::setCurrentActivity(const avsCommon::avs::PlayerActivity currentActivity) {
+    ACSDK_DEBUG9(LX("setCurrentActivity").d("from", m_currentActivity).d("to", currentActivity));
+    {
+        std::lock_guard<std::mutex> lock(m_currentActivityMutex);
+        m_currentActivity = currentActivity;
+    }
+    m_currentActivityConditionVariable.notify_all();
+}
+
+void ExternalMediaPlayer::setPlayerInFocus(const std::string& playerInFocus, bool focusAcquire) {
+    ACSDK_DEBUG9(LX("setPlayerInFocus").d("playerInFocus", playerInFocus).d("focusAcquire", focusAcquire ? "true" : "false"));
+    if (focusAcquire) {
+		//std::lock_guard<std::mutex> lock{m_inFocusAdapterMutex};
+        m_playerInFocus = playerInFocus;
+        m_playbackRouter->setHandler(shared_from_this());
+        // Acquire the channel and have this ExternalMediaPlayer manage the focus state.
+        if (m_focus == FocusState::NONE && m_focusAcquireInProgress != true) {
+            m_currentActivity = avsCommon::avs::PlayerActivity::IDLE;
+            m_haltInitiator = HaltInitiator::NONE;
+            m_focusAcquireInProgress = true;
+            m_focusManager->acquireChannel(CHANNEL_NAME, shared_from_this(), FOCUS_MANAGER_ACTIVITY_ID);
+        }
+    }
+    else if (playerInFocus.compare(m_playerInFocus) == 0 && m_focus != avsCommon::avs::FocusState::NONE) {
+        // We only release the channel when the player is the player in focus.
+        m_focusManager->releaseChannel(CHANNEL_NAME, shared_from_this());
+    }
+}
+
+#endif
+
 void ExternalMediaPlayer::setObserver(
     std::shared_ptr<avsCommon::sdkInterfaces::RenderPlayerInfoCardsObserverInterface> observer) {
     ACSDK_DEBUG5(LX(__func__));
@@ -609,29 +1034,33 @@ void ExternalMediaPlayer::setPlayerInFocus(const std::string& playerInFocus) {
 }
 
 void ExternalMediaPlayer::onButtonPressed(PlaybackButton button) {
-    std::lock_guard<std::mutex> lock{m_inFocusAdapterMutex};
-    if (!m_adapterInFocus) {
-        ACSDK_ERROR(LX("onButtonPressedFailed").d("reason", "NoActiveAdapter").d("player", m_playerInFocus));
-        return;
-    }
-
-    auto buttonIt = g_buttonToRequestType.find(button);
+	auto buttonIt = g_buttonToRequestType.find(button);
 
     if (g_buttonToRequestType.end() == buttonIt) {
         ACSDK_ERROR(LX("ButtonToRequestTypeNotFound").d("button", button));
         return;
     }
 
-    m_adapterInFocus->handlePlayControl(buttonIt->second);
-}
-
-void ExternalMediaPlayer::onTogglePressed(PlaybackToggle toggle, bool action) {
-    std::lock_guard<std::mutex> lock{m_inFocusAdapterMutex};
-    if (!m_adapterInFocus) {
-        ACSDK_ERROR(LX("onTogglePressedFailed").d("reason", "NoActiveAdapter").d("player", m_playerInFocus));
+	std::lock_guard<std::mutex> lock{m_inFocusAdapterMutex};
+#ifdef EXTERNALMEDIAPLAYER_1_1
+	if (!m_playerInFocus.empty()) {
+		setHaltInitiatorRequestHelper(buttonIt->second);
+	    m_executor.submit([this, buttonIt]() {
+	        for (auto adapterHandler : m_adapterHandlers) {
+	            adapterHandler->playControlForPlayer(m_playerInFocus, buttonIt->second);
+	        }
+	    });
+	}
+#else
+	if (!m_adapterInFocus) {
+        ACSDK_ERROR(LX("onButtonPressedFailed").d("reason", "NoActiveAdapter").d("player", m_playerInFocus));
         return;
     }
+	m_adapterInFocus->handlePlayControl(buttonIt->second);
+#endif
+}
 
+void ExternalMediaPlayer::onTogglePressed(PlaybackToggle toggle, bool action) {
     auto toggleIt = g_toggleToRequestType.find(toggle);
     if (g_toggleToRequestType.end() == toggleIt) {
         ACSDK_ERROR(LX("ToggleToRequestTypeNotFound").d("toggle", toggle));
@@ -641,15 +1070,38 @@ void ExternalMediaPlayer::onTogglePressed(PlaybackToggle toggle, bool action) {
     // toggleStates map is <SELECTED,DESELECTED>
     auto toggleStates = toggleIt->second;
 
+    std::lock_guard<std::mutex> lock{m_inFocusAdapterMutex};
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    m_executor.submit([this, action, toggleStates]() {
+        for (auto adapterHandler : m_adapterHandlers) {
+            if (action) {
+                adapterHandler->playControlForPlayer(m_playerInFocus, toggleStates.first);
+            }
+            else {
+                adapterHandler->playControlForPlayer(m_playerInFocus, toggleStates.second);
+            }
+        }
+    });
+#else
+    if (!m_adapterInFocus) {
+        ACSDK_ERROR(LX("onTogglePressedFailed").d("reason", "NoActiveAdapter").d("player", m_playerInFocus));
+        return;
+    }
+
     if (action) {
         m_adapterInFocus->handlePlayControl(toggleStates.first);
     } else {
         m_adapterInFocus->handlePlayControl(toggleStates.second);
     }
+#endif
 }
 
 void ExternalMediaPlayer::doShutdown() {
     m_executor.shutdown();
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    m_adapterHandlers.clear();
+    m_focusManager.reset();
+#endif
     // Reset the EMP from being a state provider. If not there would be calls from the adapter to provide context
     // which will try to add tasks to the executor thread.
     m_contextManager->setStateProvider(SESSION_STATE, nullptr);
@@ -682,6 +1134,29 @@ void ExternalMediaPlayer::removeDirective(std::shared_ptr<DirectiveInfo> info) {
     }
 }
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+void ExternalMediaPlayer::setHaltInitiatorRequestHelper(RequestType request) {
+    switch (request) {
+        case RequestType::PAUSE:
+            m_haltInitiator = HaltInitiator::EXTERNAL_PAUSE;
+            break;
+        case RequestType::PAUSE_RESUME_TOGGLE:
+            if (m_currentActivity == avsCommon::avs::PlayerActivity::PLAYING ||
+                    (m_currentActivity == avsCommon::avs::PlayerActivity::PAUSED &&
+                    m_haltInitiator == HaltInitiator::FOCUS_CHANGE_PAUSE)) {
+                m_haltInitiator = HaltInitiator::EXTERNAL_PAUSE;
+            }
+            break;
+        case RequestType::PLAY:
+        case RequestType::RESUME:
+            m_haltInitiator = HaltInitiator::NONE;
+            break;
+        default:
+            break;
+    }
+}
+#endif
+
 void ExternalMediaPlayer::setHandlingCompleted(std::shared_ptr<DirectiveInfo> info) {
     if (info && info->result) {
         info->result->setCompleted();
@@ -712,10 +1187,26 @@ void ExternalMediaPlayer::executeProvideState(
     ACSDK_DEBUG(LX("executeProvideState").d("sendToken", sendToken).d("stateRequestToken", stateRequestToken));
     std::string state;
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    std::vector<avsCommon::sdkInterfaces::externalMediaPlayer::AdapterState> adapterStates;
+    for (auto adapterHandler : m_adapterHandlers) {
+        auto handlerAdapterStates = adapterHandler->getAdapterStates();
+        adapterStates.insert(adapterStates.end(), handlerAdapterStates.begin(), handlerAdapterStates.end());
+    }
+#endif
+
     if (stateProviderName == SESSION_STATE) {
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        state = provideSessionState(adapterStates);
+#else
         state = provideSessionState();
+#endif
     } else if (stateProviderName == PLAYBACK_STATE) {
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        state = providePlaybackState(adapterStates);
+#else
         state = providePlaybackState();
+#endif
     } else {
         ACSDK_ERROR(LX("executeProvideState").d("reason", "unknownStateProviderName"));
         return;
@@ -733,13 +1224,21 @@ void ExternalMediaPlayer::executeProvideState(
     }
 }
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+std::string ExternalMediaPlayer::provideSessionState(std::vector<avsCommon::sdkInterfaces::externalMediaPlayer::AdapterState> adapterStates) {
+#else
 std::string ExternalMediaPlayer::provideSessionState() {
+#endif
     rapidjson::Document state(rapidjson::kObjectType);
     rapidjson::Document::AllocatorType& stateAlloc = state.GetAllocator();
 
     {
         std::lock_guard<std::mutex> lock{m_inFocusAdapterMutex};
         state.AddMember(rapidjson::StringRef(PLAYER_IN_FOCUS), m_playerInFocus, stateAlloc);
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        state.AddMember(rapidjson::StringRef(SPI_VERSION), rapidjson::StringRef(SPI_VERSION_DEFAULT), stateAlloc);
+        state.AddMember(rapidjson::StringRef(AGENT), rapidjson::StringRef(AGENT_DEFAULT), stateAlloc);
+#endif		
     }
 
     rapidjson::Value players(rapidjson::kArrayType);
@@ -761,6 +1260,13 @@ std::string ExternalMediaPlayer::provideSessionState() {
         notifyObservers(update.first, &update.second);
     }
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    for (auto adapterState : adapterStates) {
+        rapidjson::Value playerJson = buildSessionState(adapterState.sessionState, stateAlloc);
+        players.PushBack(playerJson, stateAlloc);
+    }
+#endif
+
     state.AddMember(rapidjson::StringRef(PLAYERS), players, stateAlloc);
 
     rapidjson::StringBuffer buffer;
@@ -773,7 +1279,11 @@ std::string ExternalMediaPlayer::provideSessionState() {
     return buffer.GetString();
 }
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+std::string ExternalMediaPlayer::providePlaybackState(std::vector<avsCommon::sdkInterfaces::externalMediaPlayer::AdapterState> adapterStates) {
+#else
 std::string ExternalMediaPlayer::providePlaybackState() {
+#endif
     rapidjson::Document state(rapidjson::kObjectType);
     rapidjson::Document::AllocatorType& stateAlloc = state.GetAllocator();
 
@@ -802,7 +1312,14 @@ std::string ExternalMediaPlayer::providePlaybackState() {
         notifyObservers(update.first, &update.second);
     }
 
-    notifyRenderPlayerInfoCardsObservers();
+    //notifyRenderPlayerInfoCardsObservers();
+
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    for (auto adapterState : adapterStates) {
+        rapidjson::Value playerJson = buildPlaybackState(adapterState.playbackState, stateAlloc);
+        players.PushBack(playerJson, stateAlloc);
+    }
+#endif
 
     state.AddMember(PLAYERS, players, stateAlloc);
 
diff --git a/CapabilityAgents/ExternalMediaPlayer/test/ExternalMediaPlayerTest.cpp b/CapabilityAgents/ExternalMediaPlayer/test/ExternalMediaPlayerTest.cpp
index 5096569e..1d2ce4d3 100644
--- a/CapabilityAgents/ExternalMediaPlayer/test/ExternalMediaPlayerTest.cpp
+++ b/CapabilityAgents/ExternalMediaPlayer/test/ExternalMediaPlayerTest.cpp
@@ -96,6 +96,9 @@ static const std::string PLAYER_STATE = "IDLE";
 static const NamespaceAndName PLAY_DIRECTIVE{EXTERNALMEDIAPLAYER_NAMESPACE, "Play"};
 static const NamespaceAndName LOGIN_DIRECTIVE{EXTERNALMEDIAPLAYER_NAMESPACE, "Login"};
 static const NamespaceAndName LOGOUT_DIRECTIVE{EXTERNALMEDIAPLAYER_NAMESPACE, "Logout"};
+#ifdef EXTERNALMEDIAPLAYER_1_1
+static const NamespaceAndName AUTHORIZEDISCOVEREDPLAYERS_DIRECTIVE{EXTERNALMEDIAPLAYER_NAMESPACE, "AuthorizeDiscoveredPlayers"};
+#endif
 
 // The @c Transport control directive signatures.
 static const NamespaceAndName RESUME_DIRECTIVE{PLAYBACKCONTROLLER_NAMESPACE, "Play"};
@@ -137,7 +140,15 @@ static const std::string IDLE_SESSION_STATE =
             "\"username\":\"\","
             "\"isGuest\":false,"
             "\"launched\":false,"
-           "\"active\":false}"
+            "\"active\":false"
+#ifdef EXTERNALMEDIAPLAYER_1_1
+            ","
+            "\"spiVersion\":\"\","
+            "\"playerCookie\":\"\","
+            "\"skillToken\":\"\","
+            "\"playbackSessionId\":\"\""
+#endif
+        "}"
     "]}";
 
 static const std::string IDLE_PLAYBACK_STATE =
@@ -260,7 +271,12 @@ public:
             bool forceLogin,
             std::chrono::milliseconds tokenRefreshInterval));
     MOCK_METHOD0(handleLogout, void());
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    MOCK_METHOD7(handlePlay, void(std::string& playContextToken, int64_t index, std::chrono::milliseconds offset,
+        std::string& skillToken, std::string& playbackSessionId, std::string& navigation, bool preload));
+#else
     MOCK_METHOD3(handlePlay, void(std::string& playContextToken, int64_t index, std::chrono::milliseconds offset));
+#endif
     MOCK_METHOD1(handlePlayControl, void(RequestType requestType));
     MOCK_METHOD1(handleSeek, void(std::chrono::milliseconds offset));
     MOCK_METHOD1(handleAdjustSeek, void(std::chrono::milliseconds deltaOffset));
@@ -321,6 +337,53 @@ std::shared_ptr<MockExternalMediaPlayerObserver> MockExternalMediaPlayerObserver
 MockExternalMediaPlayerObserver::MockExternalMediaPlayerObserver() {
 }
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+/**
+ * Method to create AuthorizeDiscoveredPlayers payload.
+ *
+ * @return A string representation of the payload.
+ */
+static std::string createAuthorizeDiscoveredPlayersPayload() {
+    // clang-format off
+    // {
+    //     "directive": {
+    //         "header": {
+    //             "namespace": "ExternalMediaPlayer",
+    //             "name": "AuthorizeDiscoveredPlayers"
+    //         },
+    //         "payload": {
+    //             "players" : [
+    //                 {
+    //                     "localPlayerId": "{{STRING}}",
+    //                     "authorized": {{BOOLEAN}},
+    //                     "metadata": {
+    //                         "playerId": "{{STRING}}",
+    //                         "skillToken": "{{STRING}}"
+    //                     }
+    //                 }
+    //             ]
+    //         }
+    //     }
+    // }
+    const std::string AUTHORIZEDISCOVEREDPLAYERS_PAYLOAD_TEST =
+        "{"
+            "\"players\" : ["
+                "{"
+                    "\"localPlayerId\": \"Spotify:ESDK\","
+                    "\"authorized\": true,"
+                    "\"metadata\": {"
+                        "\"playerId\": \"Spotify\","
+                        "\"skillToken\": \"YYY\""
+                    "}"
+                "}"
+            "]"
+        "}";
+    // clang-format on
+
+    return AUTHORIZEDISCOVEREDPLAYERS_PAYLOAD_TEST;
+}
+#endif
+
 /**
  * Method to create payload with parse error.
  *
@@ -334,7 +397,15 @@ static std::string createPlayPayloadWithParseError(
     const std::string& playContext,
     int index,
     int64_t offsetInMilliseconds,
-    const std::string& playerId) {
+    const std::string& playerId
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    ,
+    const std::string& skillToken,
+    const std::string& playbackSessionId,
+    const std::string& navigation, // DEFAULT, NONE, FOREGROUND
+    bool preload
+#endif
+    ) {
     // clang-format off
     const std::string PLAY_PAYLOAD_TEST =
         "{"
@@ -342,6 +413,13 @@ static std::string createPlayPayloadWithParseError(
             "\"offsetInMilliseconds\":" + std::to_string(offsetInMilliseconds) + "\","
             "\"playerId\":\"" + playerId + "\","
             "\"index\":\"" + std::to_string(index) + "\","
+#ifdef EXTERNALMEDIAPLAYER_1_1
+//             ","
+            "\"skillToken\":\"" + skillToken + "\","
+            "\"playbackSessionId\":\"" + playbackSessionId + "\","
+            "\"navigation\":\"" + navigation + "\"," // DEFAULT, NONE, FOREGROUND
+            "\"preload\":" + (preload ? "true" : "false") + ""
+#endif
         "}";
     // clang-format on
 
@@ -378,7 +456,15 @@ static std::string createPlayPayload(
     const std::string& playContext,
     int index,
     int64_t offsetInMilliseconds,
-    const std::string& playerId) {
+    const std::string& playerId
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    ,
+    const std::string& skillToken,
+    const std::string& playbackSessionId,
+    const std::string& navigation, // DEFAULT, NONE, FOREGROUND
+    bool preload
+#endif
+    ) {
     // clang-format off
     const std::string PLAY_PAYLOAD_TEST =
         "{"
@@ -386,6 +472,13 @@ static std::string createPlayPayload(
             "\"offsetInMilliseconds\":\"" + std::to_string(offsetInMilliseconds) + "\","
             "\"playerId\":\"" + playerId + "\","
             "\"index\":\"" + std::to_string(index) + "\""
+#ifdef EXTERNALMEDIAPLAYER_1_1
+            ","
+            "\"skillToken\":\"" + skillToken + "\","
+            "\"playbackSessionId\":\"" + playbackSessionId + "\","
+            "\"navigation\":\"" + navigation + "\"," // DEFAULT, NONE, FOREGROUND
+            "\"preload\":" + (preload ? "true" : "false") + ""
+#endif
         "}";
     // clang-format on
 
@@ -400,13 +493,28 @@ static std::string createPlayPayload(
  * @param playerId The business name of the player.
  * @return A string representation of the payload.
  */
-static std::string createPlayPayloadNoContext(int index, int64_t offsetInMilliseconds, const std::string& playerId) {
+static std::string createPlayPayloadNoContext(int index, int64_t offsetInMilliseconds, const std::string& playerId
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    ,
+    const std::string& skillToken,
+    const std::string& playbackSessionId,
+    const std::string& navigation, // DEFAULT, NONE, FOREGROUND
+    bool preload
+#endif
+) {
     // clang-format off
     const std::string PLAY_PAYLOAD_TEST =
         "{"
             "\"offsetInMilliseconds\":\"" + std::to_string(offsetInMilliseconds) + "\","
             "\"playerId\":\"" + playerId + "\","
             "\"index\":\"" + std::to_string(index) + "\""
+#ifdef EXTERNALMEDIAPLAYER_1_1
+            ","
+            "\"skillToken\":\"" + skillToken + "\","
+            "\"playbackSessionId\":\"" + playbackSessionId + "\","
+            "\"navigation\":\"" + navigation + "\"," // DEFAULT, NONE, FOREGROUND
+            "\"preload\":" + (preload ? "true" : "false") + ""
+#endif
         "}";
     // clang-format on
 
@@ -424,13 +532,28 @@ static std::string createPlayPayloadNoContext(int index, int64_t offsetInMillise
 static std::string createPlayPayloadNoPlayerId(
     const std::string& playContext,
     int index,
-    int64_t offsetInMilliseconds) {
+    int64_t offsetInMilliseconds
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    ,
+    const std::string& skillToken,
+    const std::string& playbackSessionId,
+    const std::string& navigation, // DEFAULT, NONE, FOREGROUND
+    bool preload
+#endif
+    ) {
     // clang-format off
     const std::string PLAY_PAYLOAD_TEST =
         "{"
             "\"playbackContextToken\":\"" + playContext + "\","
             "\"offsetInMilliseconds\":\"" + std::to_string(offsetInMilliseconds) + "\","
             "\"index\":\"" + std::to_string(index) + "\""
+#ifdef EXTERNALMEDIAPLAYER_1_1
+            ","
+            "\"skillToken\":\"" + skillToken + "\","
+            "\"playbackSessionId\":\"" + playbackSessionId + "\","
+            "\"navigation\":\"" + navigation + "\"," // DEFAULT, NONE, FOREGROUND
+            "\"preload\":" + (preload ? "true" : "false") + ""
+#endif
         "}";
 
     // clang-format on
@@ -449,13 +572,28 @@ static std::string createPlayPayloadNoPlayerId(
 static std::string createPlayPayloadNoIndex(
     const std::string& playContext,
     int64_t offsetInMilliseconds,
-    const std::string& playerId) {
+    const std::string& playerId
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    ,
+    const std::string& skillToken,
+    const std::string& playbackSessionId,
+    const std::string& navigation, // DEFAULT, NONE, FOREGROUND
+    bool preload
+#endif
+    ) {
     // clang-format off
     const std::string PLAY_PAYLOAD_TEST =
         "{"
             "\"playbackContextToken\":\"" + playContext + "\","
             "\"offsetInMilliseconds\":" + std::to_string(offsetInMilliseconds) + ","
             "\"playerId\":\"" + playerId + "\""
+#ifdef EXTERNALMEDIAPLAYER_1_1
+            ","
+            "\"skillToken\":\"" + skillToken + "\","
+            "\"playbackSessionId\":\"" + playbackSessionId + "\","
+            "\"navigation\":\"" + navigation + "\"," // DEFAULT, NONE, FOREGROUND
+            "\"preload\":" + (preload ? "true" : "false") + ""
+#endif
         "}";
 
     // clang-format on
@@ -471,13 +609,28 @@ static std::string createPlayPayloadNoIndex(
  * @param playerId The business name of the player.
  * @return A string representation of the payload.
  */
-static std::string createPlayPayloadNoOffset(const std::string& playContext, int index, const std::string& playerId) {
+static std::string createPlayPayloadNoOffset(const std::string& playContext, int index, const std::string& playerId
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    ,
+    const std::string& skillToken,
+    const std::string& playbackSessionId,
+    const std::string& navigation, // DEFAULT, NONE, FOREGROUND
+    bool preload
+#endif
+) {
     // clang-format off
     const std::string PLAY_PAYLOAD_TEST =
         "{"
             "\"playbackContextToken\":\"" + playContext + "\","
             "\"playerId\":\"" + playerId + "\","
             "\"index\":\"" + std::to_string(index) + "\""
+#ifdef EXTERNALMEDIAPLAYER_1_1
+            ","
+            "\"skillToken\":\"" + skillToken + "\","
+            "\"playbackSessionId\":\"" + playbackSessionId + "\","
+            "\"navigation\":\"" + navigation + "\"," // DEFAULT, NONE, FOREGROUND
+            "\"preload\":" + (preload ? "true" : "false") + ""
+#endif
         "}";
 
     // clang-format on
@@ -814,6 +967,9 @@ TEST_F(ExternalMediaPlayerTest, test_getConfiguration) {
 
     // TODO: ARC-227 Verify default values
     ASSERT_EQ(configuration[PLAY_DIRECTIVE], audioNonBlockingPolicy);
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    ASSERT_EQ(configuration[AUTHORIZEDISCOVEREDPLAYERS_DIRECTIVE], audioNonBlockingPolicy);
+#endif
     ASSERT_EQ(configuration[LOGIN_DIRECTIVE], neitherNonBlockingPolicy);
     ASSERT_EQ(configuration[LOGOUT_DIRECTIVE], neitherNonBlockingPolicy);
     ASSERT_EQ(configuration[RESUME_DIRECTIVE], audioNonBlockingPolicy);
@@ -888,7 +1044,11 @@ TEST_F(ExternalMediaPlayerTest, test_playParserError) {
         PLAY_DIRECTIVE.nameSpace, PLAY_DIRECTIVE.name, MESSAGE_ID_TEST, DIALOG_REQUEST_ID_TEST);
 
     std::shared_ptr<AVSDirective> directive = AVSDirective::create(
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        "", avsMessageHeader, createPlayPayloadWithParseError("XXX", 0, 0, "Spotify", "YYY", "ZZZ", "DEFAULT", false), m_attachmentManager, "");
+#else
         "", avsMessageHeader, createPlayPayloadWithParseError("XXX", 0, 0, "Spotify"), m_attachmentManager, "");
+#endif
 
     EXPECT_CALL(*(m_mockExceptionSender.get()), sendExceptionEncountered(_, _, _));
     EXPECT_CALL(*m_mockDirectiveHandlerResult, setFailed(_));
@@ -905,7 +1065,11 @@ TEST_F(ExternalMediaPlayerTest, test_playNoAdapter) {
         PLAY_DIRECTIVE.nameSpace, PLAY_DIRECTIVE.name, MESSAGE_ID_TEST, DIALOG_REQUEST_ID_TEST);
 
     std::shared_ptr<AVSDirective> directive =
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        AVSDirective::create("", avsMessageHeader, createPlayPayload("XXX", 0, 0, "Spotify", "YYY", "ZZZ", "DEFAULT", false), m_attachmentManager, "");
+#else
         AVSDirective::create("", avsMessageHeader, createPlayPayload("XXX", 0, 0, "Spotify"), m_attachmentManager, "");
+#endif
 
     EXPECT_CALL(*(m_mockExceptionSender.get()), sendExceptionEncountered(_, _, _));
     EXPECT_CALL(*m_mockDirectiveHandlerResult, setFailed(_));
@@ -922,7 +1086,11 @@ TEST_F(ExternalMediaPlayerTest, test_playNoPlayContext) {
         PLAY_DIRECTIVE.nameSpace, PLAY_DIRECTIVE.name, MESSAGE_ID_TEST, DIALOG_REQUEST_ID_TEST);
 
     std::shared_ptr<AVSDirective> directive = AVSDirective::create(
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        "", avsMessageHeader, createPlayPayloadNoContext(0, 0, MSP_NAME1, "YYY", "ZZZ", "DEFAULT", false), m_attachmentManager, "");
+#else
         "", avsMessageHeader, createPlayPayloadNoContext(0, 0, MSP_NAME1), m_attachmentManager, "");
+#endif
 
     EXPECT_CALL(*(m_mockExceptionSender.get()), sendExceptionEncountered(_, _, _));
     EXPECT_CALL(*m_mockDirectiveHandlerResult, setFailed(_));
@@ -939,7 +1107,11 @@ TEST_F(ExternalMediaPlayerTest, test_playNoPlayerId) {
         PLAY_DIRECTIVE.nameSpace, PLAY_DIRECTIVE.name, MESSAGE_ID_TEST, DIALOG_REQUEST_ID_TEST);
 
     std::shared_ptr<AVSDirective> directive =
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        AVSDirective::create("", avsMessageHeader, createPlayPayloadNoPlayerId("XXX", 0, 0, "YYY", "ZZZ", "DEFAULT", false), m_attachmentManager, "");
+#else
         AVSDirective::create("", avsMessageHeader, createPlayPayloadNoPlayerId("XXX", 0, 0), m_attachmentManager, "");
+#endif
 
     EXPECT_CALL(*(m_mockExceptionSender.get()), sendExceptionEncountered(_, _, _));
     EXPECT_CALL(*m_mockDirectiveHandlerResult, setFailed(_));
@@ -956,9 +1128,17 @@ TEST_F(ExternalMediaPlayerTest, test_playNoOffset) {
         PLAY_DIRECTIVE.nameSpace, PLAY_DIRECTIVE.name, MESSAGE_ID_TEST, DIALOG_REQUEST_ID_TEST);
 
     std::shared_ptr<AVSDirective> directive = AVSDirective::create(
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        "", avsMessageHeader, createPlayPayloadNoOffset("XXX", 0, MSP_NAME1, "YYY", "ZZZ", "DEFAULT", false), m_attachmentManager, "");
+#else
         "", avsMessageHeader, createPlayPayloadNoOffset("XXX", 0, MSP_NAME1), m_attachmentManager, "");
+#endif
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    EXPECT_CALL(*(MockExternalMediaPlayerAdapter::m_currentActiveMediaPlayerAdapter), handlePlay(_, _, _, _, _, _, _));
+#else
     EXPECT_CALL(*(MockExternalMediaPlayerAdapter::m_currentActiveMediaPlayerAdapter), handlePlay(_, _, _));
+#endif
     EXPECT_CALL(*m_mockDirectiveHandlerResult, setCompleted());
 
     m_externalMediaPlayer->CapabilityAgent::preHandleDirective(directive, std::move(m_mockDirectiveHandlerResult));
@@ -973,15 +1153,39 @@ TEST_F(ExternalMediaPlayerTest, test_playNoIndex) {
         PLAY_DIRECTIVE.nameSpace, PLAY_DIRECTIVE.name, MESSAGE_ID_TEST, DIALOG_REQUEST_ID_TEST);
 
     std::shared_ptr<AVSDirective> directive = AVSDirective::create(
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        "", avsMessageHeader, createPlayPayloadNoIndex("XXX", 0, MSP_NAME1, "YYY", "ZZZ", "DEFAULT", false), m_attachmentManager, "");
+#else
         "", avsMessageHeader, createPlayPayloadNoIndex("XXX", 0, MSP_NAME1), m_attachmentManager, "");
+#endif
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    EXPECT_CALL(*(MockExternalMediaPlayerAdapter::m_currentActiveMediaPlayerAdapter), handlePlay(_, _, _, _, _, _, _));
+#else
     EXPECT_CALL(*(MockExternalMediaPlayerAdapter::m_currentActiveMediaPlayerAdapter), handlePlay(_, _, _));
+#endif
     EXPECT_CALL(*m_mockDirectiveHandlerResult, setCompleted());
 
     m_externalMediaPlayer->CapabilityAgent::preHandleDirective(directive, std::move(m_mockDirectiveHandlerResult));
     m_externalMediaPlayer->CapabilityAgent::handleDirective(MESSAGE_ID_TEST);
 }
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+/**
+ * Test successful AuthorizeDiscoveredPlayers.
+ */
+TEST_F(ExternalMediaPlayerTest, testAuthorizeDiscoveredPlayers) {
+    auto avsMessageHeader = std::make_shared<AVSMessageHeader>(
+        AUTHORIZEDISCOVEREDPLAYERS_DIRECTIVE.nameSpace, AUTHORIZEDISCOVEREDPLAYERS_DIRECTIVE.name, MESSAGE_ID_TEST, DIALOG_REQUEST_ID_TEST);
+
+    std::shared_ptr<AVSDirective> directive =
+        AVSDirective::create("", avsMessageHeader, createAuthorizeDiscoveredPlayersPayload(), m_attachmentManager, "");
+
+    m_externalMediaPlayer->CapabilityAgent::preHandleDirective(directive, std::move(m_mockDirectiveHandlerResult));
+    m_externalMediaPlayer->CapabilityAgent::handleDirective(MESSAGE_ID_TEST);
+}
+#endif
+
 /**
  * Test successful logout.
  */
diff --git a/CapabilityAgents/MRM/include/MRM/MRMCapabilityAgent.h b/CapabilityAgents/MRM/include/MRM/MRMCapabilityAgent.h
index 8775551f..ffc28d27 100644
--- a/CapabilityAgents/MRM/include/MRM/MRMCapabilityAgent.h
+++ b/CapabilityAgents/MRM/include/MRM/MRMCapabilityAgent.h
@@ -107,7 +107,7 @@ public:
 
     /// @name Overridden @c CallStateObserverInterface methods
     /// @{
-    void onCallStateChange(avsCommon::sdkInterfaces::CallStateObserverInterface::CallState callState) override;
+    void onCallStateChange(avsCommon::sdkInterfaces::CallStateObserverInterface::CallState callState, const avsCommon::sdkInterfaces::CallStateObserverInterface::CallDisplayInfo& displayInfo) override;
     /// @}
 
     /// @name Overridden CapabilityConfigurationInterface methods.
@@ -182,7 +182,7 @@ private:
     /**
      * This function handles when the CallState has been changed.
      */
-    void executeOnCallStateChange(const avsCommon::sdkInterfaces::CallStateObserverInterface::CallState state);
+    void executeOnCallStateChange(const avsCommon::sdkInterfaces::CallStateObserverInterface::CallState state, const avsCommon::sdkInterfaces::CallStateObserverInterface::CallDisplayInfo& displayInfo);
 
     /**
      * This function handles when a System.UserInactivityReport has been sent to
@@ -213,4 +213,4 @@ private:
 }  // namespace capabilityAgents
 }  // namespace alexaClientSDK
 
-#endif  // ALEXA_CLIENT_SDK_CAPABILITYAGENTS_MRM_INCLUDE_MRM_MRMCAPABILITYAGENT_H_
\ No newline at end of file
+#endif  // ALEXA_CLIENT_SDK_CAPABILITYAGENTS_MRM_INCLUDE_MRM_MRMCAPABILITYAGENT_H_
diff --git a/CapabilityAgents/MRM/src/MRMCapabilityAgent.cpp b/CapabilityAgents/MRM/src/MRMCapabilityAgent.cpp
index 03b97001..8dadc589 100644
--- a/CapabilityAgents/MRM/src/MRMCapabilityAgent.cpp
+++ b/CapabilityAgents/MRM/src/MRMCapabilityAgent.cpp
@@ -153,9 +153,9 @@ void MRMCapabilityAgent::onSpeakerSettingsChanged(
     m_executor.submit([this, type]() { executeOnSpeakerSettingsChanged(type); });
 }
 
-void MRMCapabilityAgent::onCallStateChange(avsCommon::sdkInterfaces::CallStateObserverInterface::CallState callState) {
+void MRMCapabilityAgent::onCallStateChange(avsCommon::sdkInterfaces::CallStateObserverInterface::CallState callState, const CallDisplayInfo& displayInfo) {
     ACSDK_DEBUG5(LX(__func__).d("callState", callState));
-    m_executor.submit([this, callState]() { executeOnCallStateChange(callState); });
+    m_executor.submit([this, callState, displayInfo]() { executeOnCallStateChange(callState, displayInfo); });
 }
 
 std::string MRMCapabilityAgent::getVersionString() const {
@@ -206,7 +206,7 @@ void MRMCapabilityAgent::executeSetObserver(
 }
 
 void MRMCapabilityAgent::executeOnCallStateChange(
-    const avsCommon::sdkInterfaces::CallStateObserverInterface::CallState callState) {
+    const avsCommon::sdkInterfaces::CallStateObserverInterface::CallState callState, const avsCommon::sdkInterfaces::CallStateObserverInterface::CallDisplayInfo& displayInfo) {
     ACSDK_DEBUG5(LX(__func__));
     bool active =
         (CallStateObserverInterface::CallState::CONNECTING == callState ||
diff --git a/CapabilityAgents/PlaybackController/include/PlaybackController/PlaybackController.h b/CapabilityAgents/PlaybackController/include/PlaybackController/PlaybackController.h
index 078dc4ca..c02d9f57 100644
--- a/CapabilityAgents/PlaybackController/include/PlaybackController/PlaybackController.h
+++ b/CapabilityAgents/PlaybackController/include/PlaybackController/PlaybackController.h
@@ -25,6 +25,7 @@
 #include <AVSCommon/SDKInterfaces/CapabilityConfigurationInterface.h>
 #include <AVSCommon/SDKInterfaces/ContextManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/ContextRequesterInterface.h>
+#include <AVSCommon/SDKInterfaces/FocusManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/MessageSenderInterface.h>
 #include <AVSCommon/SDKInterfaces/PlaybackHandlerInterface.h>
 #include <AVSCommon/Utils/RequiresShutdown.h>
@@ -48,11 +49,14 @@ public:
      *
      * @param contextManager The @c ContextManagerInterface used to generate system context for events.
      * @param messageSender The @c MessageSenderInterface that sends events to AVS.
+     * @param focusManager The optional @c FocusManagerInterface that manages channel focus if the 
+     * @c PlaybackController should release the content channel on 'Pause' button press
      * @return @c nullptr if the inputs are not defined, else a new instance of @c PlaybackController.
      */
     static std::shared_ptr<PlaybackController> create(
         std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
-        std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender);
+        std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender,
+        std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerInterface> focusManager = nullptr);
 
     /**
      * Destructor.
@@ -92,10 +96,13 @@ private:
      *
      * @param contextManager The AVS Context manager used to generate system context for events.
      * @param messageSender The message sender interface that sends events to AVS.
+     * @param focusManager The optional channel focus manager if the @c PlaybackController should release the content 
+     * channel on 'Pause' button press
      */
     PlaybackController(
         std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
-        std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender);
+        std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender,
+        std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerInterface> focusManager = nullptr);
 
     // @name RequiresShutdown Functions
     /// @{
@@ -123,6 +130,9 @@ private:
     /// The @c ContextManager used to generate system context for events.
     std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> m_contextManager;
 
+    /// The @c FocusManager used to manage usage of the content channel.
+    std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerInterface> m_focusManager;
+
     /// The queue for storing the commands.
     std::queue<const PlaybackCommand*> m_commands;
     /// @}
diff --git a/CapabilityAgents/PlaybackController/src/PlaybackController.cpp b/CapabilityAgents/PlaybackController/src/PlaybackController.cpp
index f29ae74b..8a99117d 100644
--- a/CapabilityAgents/PlaybackController/src/PlaybackController.cpp
+++ b/CapabilityAgents/PlaybackController/src/PlaybackController.cpp
@@ -50,6 +50,12 @@ static const std::string TAG("PlaybackController");
 /// String to identify the AVS namespace of the event we send.
 static const std::string PLAYBACK_CONTROLLER_NAMESPACE = "PlaybackController";
 
+/// The name of the @c FocusManager channel used by @c PlaybackController.
+static const std::string CHANNEL_NAME = avsCommon::sdkInterfaces::FocusManagerInterface::CONTENT_CHANNEL_NAME;
+
+/// The name of the @c PlaybackController pause command event.
+static const std::string PAUSE_EVENT_NAME = "PauseCommandIssued";
+
 /**
  * Creates the PlaybackController capability configuration.
  *
@@ -59,7 +65,8 @@ static std::shared_ptr<CapabilityConfiguration> getPlaybackControllerCapabilityC
 
 std::shared_ptr<PlaybackController> PlaybackController::create(
     std::shared_ptr<ContextManagerInterface> contextManager,
-    std::shared_ptr<MessageSenderInterface> messageSender) {
+    std::shared_ptr<MessageSenderInterface> messageSender,
+    std::shared_ptr<FocusManagerInterface> focusManager) {
     if (!contextManager) {
         ACSDK_ERROR(LX("createFailed").d("reason", "nullContextManager"));
         return nullptr;
@@ -68,14 +75,14 @@ std::shared_ptr<PlaybackController> PlaybackController::create(
         ACSDK_ERROR(LX("createFailed").d("reason", "nullMessageSender"));
         return nullptr;
     }
-
-    return std::shared_ptr<PlaybackController>(new PlaybackController(contextManager, messageSender));
+    return std::shared_ptr<PlaybackController>(new PlaybackController(contextManager, messageSender, focusManager));
 }
 
 void PlaybackController::doShutdown() {
     m_executor.shutdown();
     m_messageSender.reset();
     m_contextManager.reset();
+    m_focusManager.reset();
 }
 
 void PlaybackController::handleCommand(const PlaybackCommand& command) {
@@ -126,10 +133,16 @@ void PlaybackController::onContextAvailable(const std::string& jsonContext) {
         auto& command = *m_commands.front();
         m_commands.pop();
 
-        auto msgIdAndJsonEvent = buildJsonEventString(
-            PLAYBACK_CONTROLLER_NAMESPACE, command.getEventName(), "", command.getEventPayload(), jsonContext);
-        m_messageSender->sendMessage(
-            std::make_shared<PlaybackMessageRequest>(command, msgIdAndJsonEvent.second, shared_from_this()));
+        if (command.getEventName() == PAUSE_EVENT_NAME && m_focusManager != nullptr) {
+            ACSDK_DEBUG9(LX("onContextAvailableExecutor").m("skippingPauseCommandIssued").m("releasingFocus"));
+            m_focusManager->releaseChannel(CHANNEL_NAME);
+        } else {
+            auto msgIdAndJsonEvent = buildJsonEventString(
+                PLAYBACK_CONTROLLER_NAMESPACE, command.getEventName(), "", command.getEventPayload(), jsonContext);
+            m_messageSender->sendMessage(
+                std::make_shared<PlaybackMessageRequest>(command, msgIdAndJsonEvent.second, shared_from_this()));
+        }
+
         if (!m_commands.empty()) {
             ACSDK_DEBUG9(LX("onContextAvailableExecutor").m("Queue is not empty, call getContext()."));
             m_contextManager->getContext(shared_from_this());
@@ -164,10 +177,12 @@ void PlaybackController::onContextFailure(const ContextRequestError error) {
 
 PlaybackController::PlaybackController(
     std::shared_ptr<ContextManagerInterface> contextManager,
-    std::shared_ptr<MessageSenderInterface> messageSender) :
+    std::shared_ptr<MessageSenderInterface> messageSender,
+    std::shared_ptr<FocusManagerInterface> focusManager) :
         RequiresShutdown{"PlaybackController"},
         m_messageSender{messageSender},
-        m_contextManager{contextManager} {
+        m_contextManager{contextManager},
+        m_focusManager{focusManager} {
     m_capabilityConfigurations.insert(getPlaybackControllerCapabilityConfiguration());
 }
 
diff --git a/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp b/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp
index ec148c0e..7592c357 100644
--- a/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp
+++ b/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp
@@ -230,8 +230,12 @@ void SpeechSynthesizer::handleDirective(std::shared_ptr<DirectiveInfo> info) {
 }
 
 void SpeechSynthesizer::cancelDirective(std::shared_ptr<DirectiveInfo> info) {
-    ACSDK_DEBUG9(LX("cancelDirective").d("messageId", info->directive->getMessageId()));
-    m_executor.submit([this, info]() { executeCancel(info); });
+    if (info && info->directive) {
+        ACSDK_DEBUG9(LX("cancelDirective").d("messageId", info->directive->getMessageId()));
+        m_executor.submit([this, info]() { executeCancel(info); });
+    } else {
+        ACSDK_WARN(LX("cancelDirective").d("reason", "infoNotAvailable"));
+    }
 }
 
 void SpeechSynthesizer::onFocusChanged(FocusState newFocus) {
@@ -937,8 +941,12 @@ std::string SpeechSynthesizer::buildPayload(std::string& token) {
 
 void SpeechSynthesizer::startPlaying() {
     ACSDK_DEBUG9(LX("startPlaying"));
-    std::shared_ptr<AttachmentReader> attachmentReader = std::move(m_currentInfo->attachmentReader);
-    m_mediaSourceId = m_speechPlayer->setSource(std::move(attachmentReader));
+    if (m_currentInfo && m_currentInfo->attachmentReader) {
+        std::shared_ptr<AttachmentReader> attachmentReader = std::move(m_currentInfo->attachmentReader);
+        m_mediaSourceId = m_speechPlayer->setSource(std::move(attachmentReader));
+    } else {
+        m_mediaSourceId = MediaPlayerInterface::ERROR;
+    }
     if (m_captionManager && m_currentInfo->captionData.isValid()) {
         m_captionManager->onCaption(m_mediaSourceId, m_currentInfo->captionData);
     }
@@ -1004,9 +1012,14 @@ void SpeechSynthesizer::setDesiredState(SpeechSynthesizerObserverInterface::Spee
 void SpeechSynthesizer::resetCurrentInfo(std::shared_ptr<SpeakDirectiveInfo> speakInfo) {
     if (m_currentInfo != speakInfo) {
         if (m_currentInfo) {
-            removeSpeakDirectiveInfo(m_currentInfo->directive->getMessageId());
-            removeDirective(m_currentInfo->directive->getMessageId());
-            m_currentInfo->clear();
+            auto info = m_currentInfo;
+            if (info) {
+                if (info->directive) {
+                    removeSpeakDirectiveInfo(info->directive->getMessageId());
+                    removeDirective(info->directive->getMessageId());
+                }
+                info->clear();
+            }
         }
         m_currentInfo = speakInfo;
     }
diff --git a/CapabilityAgents/SpeechSynthesizer/test/SpeechSynthesizerTest.cpp b/CapabilityAgents/SpeechSynthesizer/test/SpeechSynthesizerTest.cpp
index 21f7e693..25a03f3d 100644
--- a/CapabilityAgents/SpeechSynthesizer/test/SpeechSynthesizerTest.cpp
+++ b/CapabilityAgents/SpeechSynthesizer/test/SpeechSynthesizerTest.cpp
@@ -903,6 +903,143 @@ TEST_F(SpeechSynthesizerTest, testTimer_notCallStopTwice) {
     ASSERT_TRUE(m_mockSpeechPlayer->waitUntilPlaybackStarted());
 }
 
+TEST_F(SpeechSynthesizerTest, testCallingCancelBeforeOnFocusChanged) {
+    auto avsMessageHeader = std::make_shared<AVSMessageHeader>(
+        NAMESPACE_SPEECH_SYNTHESIZER, NAME_SPEAK, MESSAGE_ID_TEST, DIALOG_REQUEST_ID_TEST);
+    std::shared_ptr<AVSDirective> directive =
+        AVSDirective::create("", avsMessageHeader, PAYLOAD_TEST, m_attachmentManager, CONTEXT_ID_TEST);
+
+    auto avsMessageHeader2 =
+        std::make_shared<AVSMessageHeader>(NAMESPACE_SPEECH_SYNTHESIZER, NAME_SPEAK, MESSAGE_ID_TEST_2);
+    std::shared_ptr<AVSDirective> directive2 =
+        AVSDirective::create("", avsMessageHeader2, PAYLOAD_TEST, m_attachmentManager, CONTEXT_ID_TEST_2);
+
+    EXPECT_CALL(*(m_mockFocusManager.get()), acquireChannel(CHANNEL_NAME, _, NAMESPACE_SPEECH_SYNTHESIZER))
+        .Times(AtLeast(1))
+        .WillRepeatedly(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnAcquireChannel));
+    EXPECT_CALL(*(m_mockDirHandlerResult.get()), setFailed(_))
+        .Times(1)
+        .WillOnce(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSetFailed));
+
+    EXPECT_CALL(
+        *(m_mockContextManager.get()),
+        setState(NAMESPACE_AND_NAME_SPEECH_STATE, PLAYING_STATE_TEST, StateRefreshPolicy::ALWAYS, 0))
+        .Times(AtLeast(1))
+        .WillRepeatedly(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSetState));
+
+    EXPECT_CALL(
+        *(m_mockContextManager.get()),
+        setState(NAMESPACE_AND_NAME_SPEECH_STATE, FINISHED_STATE_TEST, StateRefreshPolicy::NEVER, 0))
+        .Times(AtLeast(1))
+        .WillRepeatedly(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSetState));
+    EXPECT_CALL(
+        *(m_mockSpeechPlayer.get()),
+        attachmentSetSource(A<std::shared_ptr<avsCommon::avs::attachment::AttachmentReader>>(), nullptr))
+        .Times(AtLeast(1));
+    EXPECT_CALL(*(m_mockSpeechPlayer.get()), play(_)).Times(AtLeast(1));
+    EXPECT_CALL(*(m_mockSpeechPlayer.get()), getOffset(_))
+        .Times(AtLeast(1))
+        .WillRepeatedly(Return(OFFSET_IN_CHRONO_MILLISECONDS_TEST));
+
+    m_speechSynthesizer->CapabilityAgent::preHandleDirective(directive, std::move(m_mockDirHandlerResult));
+    m_speechSynthesizer->CapabilityAgent::handleDirective(MESSAGE_ID_TEST);
+
+    ASSERT_TRUE(std::future_status::ready == m_wakeAcquireChannelFuture.wait_for(WAIT_TIMEOUT));
+    m_wakeAcquireChannelPromise = std::promise<void>();
+    m_wakeAcquireChannelFuture = m_wakeAcquireChannelPromise.get_future();
+
+    m_speechSynthesizer->CapabilityAgent::cancelDirective(MESSAGE_ID_TEST);
+    std::this_thread::sleep_for(std::chrono::milliseconds(1000));
+    m_speechSynthesizer->onFocusChanged(FocusState::FOREGROUND);
+
+    ASSERT_TRUE(std::future_status::ready == m_wakeSetStateFuture.wait_for(WAIT_TIMEOUT));
+    m_wakeSetStatePromise = std::promise<void>();
+    m_wakeSetStateFuture = m_wakeSetStatePromise.get_future();
+
+    ASSERT_TRUE(std::future_status::ready == m_wakeSetFailedFuture.wait_for(WAIT_TIMEOUT));
+    m_wakeSetFailedPromise = std::promise<void>();
+    m_wakeSetFailedFuture = m_wakeSetFailedPromise.get_future();
+
+    ASSERT_TRUE(std::future_status::ready == m_wakeSetStateFuture.wait_for(WAIT_TIMEOUT));
+    m_wakeSetStatePromise = std::promise<void>();
+    m_wakeSetStateFuture = m_wakeSetStatePromise.get_future();
+
+    // send second speak directive and make sure it working
+    m_speechSynthesizer->handleDirectiveImmediately(directive2);
+    ASSERT_TRUE(std::future_status::ready == m_wakeAcquireChannelFuture.wait_for(WAIT_TIMEOUT));
+    m_speechSynthesizer->onFocusChanged(FocusState::FOREGROUND);
+    ASSERT_TRUE(std::future_status::ready == m_wakeSetStateFuture.wait_for(WAIT_TIMEOUT));
+    ASSERT_TRUE(m_mockSpeechPlayer->waitUntilPlaybackStarted());
+}
+
+TEST_F(SpeechSynthesizerTest, testCallingCancelBeforeOnExecuteStateChanged) {
+    auto avsMessageHeader = std::make_shared<AVSMessageHeader>(
+        NAMESPACE_SPEECH_SYNTHESIZER, NAME_SPEAK, MESSAGE_ID_TEST, DIALOG_REQUEST_ID_TEST);
+    std::shared_ptr<AVSDirective> directive =
+        AVSDirective::create("", avsMessageHeader, PAYLOAD_TEST, m_attachmentManager, CONTEXT_ID_TEST);
+
+    auto avsMessageHeader2 =
+        std::make_shared<AVSMessageHeader>(NAMESPACE_SPEECH_SYNTHESIZER, NAME_SPEAK, MESSAGE_ID_TEST_2);
+    std::shared_ptr<AVSDirective> directive2 =
+        AVSDirective::create("", avsMessageHeader2, PAYLOAD_TEST, m_attachmentManager, CONTEXT_ID_TEST_2);
+
+    EXPECT_CALL(*(m_mockFocusManager.get()), acquireChannel(CHANNEL_NAME, _, NAMESPACE_SPEECH_SYNTHESIZER))
+        .Times(AtLeast(1))
+        .WillRepeatedly(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnAcquireChannel));
+    EXPECT_CALL(*(m_mockDirHandlerResult.get()), setFailed(_))
+        .Times(1)
+        .WillOnce(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSetFailed));
+
+    EXPECT_CALL(
+        *(m_mockContextManager.get()),
+        setState(NAMESPACE_AND_NAME_SPEECH_STATE, PLAYING_STATE_TEST, StateRefreshPolicy::ALWAYS, 0))
+        .Times(AtLeast(1))
+        .WillRepeatedly(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSetState));
+
+    EXPECT_CALL(
+        *(m_mockContextManager.get()),
+        setState(NAMESPACE_AND_NAME_SPEECH_STATE, FINISHED_STATE_TEST, StateRefreshPolicy::NEVER, 0))
+        .Times(AtLeast(1))
+        .WillRepeatedly(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSetState));
+    EXPECT_CALL(
+        *(m_mockSpeechPlayer.get()),
+        attachmentSetSource(A<std::shared_ptr<avsCommon::avs::attachment::AttachmentReader>>(), nullptr))
+        .Times(AtLeast(1));
+    EXPECT_CALL(*(m_mockSpeechPlayer.get()), play(_)).Times(AtLeast(1));
+    EXPECT_CALL(*(m_mockSpeechPlayer.get()), getOffset(_))
+        .Times(AtLeast(1))
+        .WillRepeatedly(Return(OFFSET_IN_CHRONO_MILLISECONDS_TEST));
+
+    m_speechSynthesizer->CapabilityAgent::preHandleDirective(directive, std::move(m_mockDirHandlerResult));
+    m_speechSynthesizer->CapabilityAgent::handleDirective(MESSAGE_ID_TEST);
+
+    ASSERT_TRUE(std::future_status::ready == m_wakeAcquireChannelFuture.wait_for(WAIT_TIMEOUT));
+    m_wakeAcquireChannelPromise = std::promise<void>();
+    m_wakeAcquireChannelFuture = m_wakeAcquireChannelPromise.get_future();
+
+    m_speechSynthesizer->CapabilityAgent::cancelDirective(MESSAGE_ID_TEST);
+    m_speechSynthesizer->onFocusChanged(FocusState::FOREGROUND);
+
+    ASSERT_TRUE(std::future_status::ready == m_wakeSetStateFuture.wait_for(WAIT_TIMEOUT));
+    m_wakeSetStatePromise = std::promise<void>();
+    m_wakeSetStateFuture = m_wakeSetStatePromise.get_future();
+
+    ASSERT_TRUE(std::future_status::ready == m_wakeSetFailedFuture.wait_for(WAIT_TIMEOUT));
+    m_wakeSetFailedPromise = std::promise<void>();
+    m_wakeSetFailedFuture = m_wakeSetFailedPromise.get_future();
+
+    ASSERT_TRUE(std::future_status::ready == m_wakeSetStateFuture.wait_for(WAIT_TIMEOUT));
+    m_wakeSetStatePromise = std::promise<void>();
+    m_wakeSetStateFuture = m_wakeSetStatePromise.get_future();
+
+    // send second speak directive and make sure it working
+    m_speechSynthesizer->handleDirectiveImmediately(directive2);
+    ASSERT_TRUE(std::future_status::ready == m_wakeAcquireChannelFuture.wait_for(WAIT_TIMEOUT));
+    m_speechSynthesizer->onFocusChanged(FocusState::FOREGROUND);
+    ASSERT_TRUE(std::future_status::ready == m_wakeSetStateFuture.wait_for(WAIT_TIMEOUT));
+    ASSERT_TRUE(m_mockSpeechPlayer->waitUntilPlaybackStarted());
+}
+
 /**
  * Testing executeCancel() completes execution before onFocusChanged() is called.
  *
diff --git a/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp b/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp
index 16dacdd2..764e7734 100644
--- a/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp
+++ b/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp
@@ -39,7 +39,7 @@ static const std::string TEMPLATERUNTIME_CAPABILITY_INTERFACE_TYPE = "AlexaInter
 /// TemplateRuntime interface name
 static const std::string TEMPLATERUNTIME_CAPABILITY_INTERFACE_NAME = "TemplateRuntime";
 /// TemplateRuntime interface version
-static const std::string TEMPLATERUNTIME_CAPABILITY_INTERFACE_VERSION = "1.1";
+static const std::string TEMPLATERUNTIME_CAPABILITY_INTERFACE_VERSION = "1.2";
 
 /// String to identify log entries originating from this file.
 static const std::string TAG{"TemplateRuntime"};
@@ -86,13 +86,13 @@ static const std::string AUDIO_ITEM_ID_TAG{"audioItemId"};
 static const size_t MAXIMUM_QUEUE_SIZE{100};
 
 /// Default timeout for clearing the RenderTemplate display card when SpeechSynthesizer is in FINISHED state.
-static const std::chrono::milliseconds DEFAULT_TTS_FINISHED_TIMEOUT_MS{2000};
+static const std::chrono::milliseconds DEFAULT_TTS_FINISHED_TIMEOUT_MS{8000};
 
 /// Default timeout for clearing the RenderPlayerInfo display card when AudioPlayer is in FINISHED state.
 static const std::chrono::milliseconds DEFAULT_AUDIO_FINISHED_TIMEOUT_MS{2000};
 
 /// Default timeout for clearing the RenderPlayerInfo display card when AudioPlayer is in STOPPED/PAUSED state.
-static const std::chrono::milliseconds DEFAULT_AUDIO_STOPPED_PAUSED_TIMEOUT_MS{60000};
+static const std::chrono::milliseconds DEFAULT_AUDIO_STOPPED_PAUSED_TIMEOUT_MS{1800000};
 
 /**
  * Creates the TemplateRuntime capability configuration.
diff --git a/Captions/Implementation/src/SystemClockDelay.cpp b/Captions/Implementation/src/SystemClockDelay.cpp
index 77e30376..0c3cf4a9 100644
--- a/Captions/Implementation/src/SystemClockDelay.cpp
+++ b/Captions/Implementation/src/SystemClockDelay.cpp
@@ -23,7 +23,7 @@ namespace captions {
 
 void SystemClockDelay::delay(std::chrono::milliseconds milliseconds) {
     int64_t zero = 0;
-    auto duration = std::chrono::milliseconds(std::max(zero, milliseconds.count()));
+    auto duration = std::chrono::milliseconds(std::max(zero, (int64_t)milliseconds.count()));
     std::this_thread::sleep_for(duration);
 }
 
diff --git a/CertifiedSender/src/CertifiedSender.cpp b/CertifiedSender/src/CertifiedSender.cpp
index e9237071..fc27a611 100644
--- a/CertifiedSender/src/CertifiedSender.cpp
+++ b/CertifiedSender/src/CertifiedSender.cpp
@@ -184,10 +184,10 @@ inline bool shouldRetryTransmission(MessageRequestObserverInterface::Status stat
         case MessageRequestObserverInterface::Status::SUCCESS_ACCEPTED:
         case MessageRequestObserverInterface::Status::SUCCESS_NO_CONTENT:
         case MessageRequestObserverInterface::Status::SERVER_INTERNAL_ERROR_V2:
-        case MessageRequestObserverInterface::Status::CANCELED:
-        case MessageRequestObserverInterface::Status::SERVER_OTHER_ERROR:
         case MessageRequestObserverInterface::Status::BAD_REQUEST:
             return false;
+        case MessageRequestObserverInterface::Status::CANCELED:
+        case MessageRequestObserverInterface::Status::SERVER_OTHER_ERROR:
         case MessageRequestObserverInterface::Status::THROTTLED:
         case MessageRequestObserverInterface::Status::PENDING:
         case MessageRequestObserverInterface::Status::NOT_CONNECTED:
@@ -290,6 +290,7 @@ std::future<bool> CertifiedSender::sendJSONMessage(
 }
 
 bool CertifiedSender::executeSendJSONMessage(std::string jsonMessage, const std::string& uriPathExtension) {
+    ACSDK_DEBUG9(LX(__func__).sensitive("jsonMessage", jsonMessage));
     std::unique_lock<std::mutex> lock(m_mutex);
 
     int queueSize = static_cast<int>(m_messagesToSend.size());
diff --git a/Endpoints/src/EndpointBuilder.cpp b/Endpoints/src/EndpointBuilder.cpp
index ad299fa1..4788a247 100644
--- a/Endpoints/src/EndpointBuilder.cpp
+++ b/Endpoints/src/EndpointBuilder.cpp
@@ -51,8 +51,8 @@ static const std::string TAG("EndpointBuilder");
 /// String used to join attributes in the generation of the derived endpoint id.
 const std::string ENDPOINT_ID_CONCAT = "::";
 
-/// We will limit the suffix length to 10 characters for now to ensure that we don't go over the endpointId length.
-static constexpr size_t MAX_SUFFIX_LENGTH = 10;
+/// We will limit the suffix length to 64 characters for now to ensure that we don't go over the endpointId length.
+static constexpr size_t MAX_SUFFIX_LENGTH = 64;
 
 std::unique_ptr<EndpointBuilder> EndpointBuilder::create(
     const avsCommon::utils::DeviceInfo& deviceInfo,
diff --git a/Integration/test/AudioPlayerIntegrationTest.cpp b/Integration/test/AudioPlayerIntegrationTest.cpp
index 3ad32327..1b98ac33 100644
--- a/Integration/test/AudioPlayerIntegrationTest.cpp
+++ b/Integration/test/AudioPlayerIntegrationTest.cpp
@@ -45,6 +45,9 @@
 #include <AVSCommon/Utils/MediaPlayer/PooledMediaPlayerFactory.h>
 #include <AVSCommon/Utils/Logger/LogEntry.h>
 #include <Captions/CaptionManagerInterface.h>
+#include <CertifiedSender/CertifiedSender.h>
+#include <CertifiedSender/SQLiteMessageStorage.h>
+
 #ifdef GSTREAMER_MEDIA_PLAYER
 #include <MediaPlayer/MediaPlayer.h>
 #else
@@ -89,6 +92,7 @@ using namespace capabilityAgents::speechSynthesizer;
 using namespace capabilityAgents::system;
 using namespace settings;
 using namespace settings::test;
+using namespace certifiedSender;
 #ifdef GSTREAMER_MEDIA_PLAYER
 using namespace mediaPlayer;
 #endif
@@ -390,6 +394,15 @@ protected:
         m_contentMediaPlayer = std::make_shared<TestMediaPlayer>();
 #endif
 
+        auto messageStorage =
+            SQLiteMessageStorage::create(avsCommon::utils::configuration::ConfigurationNode::getRoot());
+
+        m_certifiedSender = CertifiedSender::create(
+            m_avsConnectionManager,
+            m_avsConnectionManager->getConnectionManager(),
+            std::move(messageStorage),
+            m_customerDataManager);
+
         std::vector<std::shared_ptr<MediaPlayerInterface>> players = {m_contentMediaPlayer};
         auto mockFactory = mediaPlayer::PooledMediaPlayerFactory::create(players);
 
@@ -401,6 +414,7 @@ protected:
             m_context->getContextManager(),
             m_exceptionEncounteredSender,
             m_playbackRouter,
+            m_certifiedSender,
             m_captionManager);
         ASSERT_NE(nullptr, m_audioPlayer);
         m_directiveSequencer->addDirectiveHandler(m_audioPlayer);
@@ -423,6 +437,9 @@ protected:
         if (m_audioPlayer) {
             m_audioPlayer->shutdown();
         }
+        if (m_certifiedSender) {
+            m_certifiedSender->shutdown();
+        }
         if (m_avsConnectionManager) {
             m_avsConnectionManager->shutdown();
         }
@@ -547,6 +564,7 @@ protected:
     std::unique_ptr<ACLTestContext> m_context;
 
     std::shared_ptr<TestMessageSender> m_avsConnectionManager;
+    std::shared_ptr<CertifiedSender> m_certifiedSender;
     std::shared_ptr<TestExceptionEncounteredSender> m_exceptionEncounteredSender;
     std::shared_ptr<PlaybackController> m_playbackController;
     std::shared_ptr<PlaybackRouter> m_playbackRouter;
@@ -569,6 +587,7 @@ protected:
     std::shared_ptr<MockSetting<WakeWordConfirmationSettingType>> m_mockWakeWordConfirmationSetting;
     std::shared_ptr<MockSetting<SpeechConfirmationSettingType>> m_mockSpeechConfirmationSetting;
     std::shared_ptr<captions::CaptionManagerInterface> m_captionManager;
+    std::shared_ptr<registrationManager::CustomerDataManager> m_customerDataManager;
 
     FocusState m_focusState;
     std::mutex m_mutex;
diff --git a/SampleApp/include/SampleApp/InteractionManager.h b/SampleApp/include/SampleApp/InteractionManager.h
index 522b7136..0bb0a331 100644
--- a/SampleApp/include/SampleApp/InteractionManager.h
+++ b/SampleApp/include/SampleApp/InteractionManager.h
@@ -361,7 +361,7 @@ public:
     /**
      * CallStateObserverInterface methods
      */
-    void onCallStateChange(CallState newState) override;
+    void onCallStateChange(CallState newState, const CallDisplayInfo& displayInfo) override;
 
 #ifdef ENABLE_PCC
     /**
diff --git a/SampleApp/src/InteractionManager.cpp b/SampleApp/src/InteractionManager.cpp
index 7005b403..d3c3bd1f 100644
--- a/SampleApp/src/InteractionManager.cpp
+++ b/SampleApp/src/InteractionManager.cpp
@@ -410,7 +410,7 @@ void InteractionManager::onDialogUXStateChanged(DialogUXState state) {
     });
 }
 
-void InteractionManager::onCallStateChange(CallState state) {
+void InteractionManager::onCallStateChange(CallState state, const CallDisplayInfo& displayInfo) {
     m_executor.submit([this, state]() {
         if (CallState::CALL_CONNECTED == state) {
             if (!m_micWrapper->isStreaming()) {
-- 
2.32.0

